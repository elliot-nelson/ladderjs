{"version":3,"sources":["app.js"],"names":["R6","Math","PI","R20","R45","R70","R72","R80","R90","R360","Viewport","[object Object]","canvas","document","getElementById","ctx","getContext","resize","force","dpi","window","devicePixelRatio","width","clientWidth","height","clientHeight","dpiWidth","dpiHeight","scale","max","ceil","center","s","h","imageSmoothingEnabled","style","cursor","fillRect","normalizeVector","p","m","sqrt","x","y","l","vectorBetween","p1","p2","angle2vector","r","cos","sin","vector2angle","v","angle","atan2","vector2point","vectorAdd","vectors","vector","arcOverlap","angleA1","angleA2","angleB1","angleB2","result","min","qr2xy","pos","q","xy2uv","u","game","camera","uv2xy","clamp","value","calculateRayIntersectionAndStep","startPos","endPos","_next","_step","diff","NaN","Infinity","T","tilesHitBy","startQ","startR","endQ","endR","tileCount","abs","stepQ","sign","stepR","intersectionQ","intersectionR","i","intersectCircleRectangle","bounds","dx","dy","invdx","invdy","cornerX","cornerY","ltime","ly","O","U","S","H","rtime","ry","ttime","tx","btime","bx","inverseRadius","lineLength","cornerdx","cornerdy","cornerDistance","innerAngle","acos","time","ix","iy","nx","ny","isNaN","innerAngleSin","angle1Sin","angle1","asin","angle2","array2d","fn","Array","from","length","tileIsPassable","brawl","room","w","maze","rgba","g","b","a","createCanvas","createElement","t","roomCenter","partialText","text","d","substr","slice","idx","indexOf","repeat","SpriteSheet","D","font","K","V","G","W","page","I","j","P","Z","C","Sprite","cb","image","Image","onload","src","base64","sheet","initBasicSprite","icon_mouse_lmb","icon_mouse","icon_mouse_rmb","player","map","data","shotgun_blast","stabguts","spindoctor","gore","hud_shells_empty","hud_shells","hud_shells_full","hud_healthbar","push","initDynamicSprite","source","drawImage","globalCompositeOperation","fillStyle","img","hud_crosshair","tiles","globalAlpha","addNoise","tilebg","shadow","gradient","createRadialGradient","addColorStop","walls","gates","wallSource","spikeSource","dialog","dialog_speech","tail","expandNineTile","dialog_hint","sprite","anchor","rotation","this","viewportSprite2uv","save","translate","rotate","restore","nt","sliceCanvas","_","random","sx","sy","KeyboardAdapter","KeyW","Input","Action","UP","KeyA","LEFT","KeyS","DOWN","KeyD","RIGHT","ArrowUp","ArrowLeft","ArrowDown","ArrowRight","Escape","MENU","arrowDirections","held","addEventListener","event","k","code","reset","state","direction","action","Object","values","zzfx","zzfxP","zzfxG","e","zzfxX","createBufferSource","f","createBuffer","zzfxR","getChannelData","set","buffer","connect","destination_","start","c","F","z","A","B","E","n","J","tan","round","zzfxV","top","AudioContext","webkitAudioContext","destination","ObliqueMystique","Audio","readyToPlay","gain_","createGain","shotgun","shellReload","damage","alarm","song","instruments","patterns","sequence","BPM","instrumentParameters","note","sample","patternChannel","notFirstBeat","stop","instrument","pitch","attenuation","outSampleOffset","sampleOffset","nextSampleOffset","panning","sampleBuffer","leftChannelBuffer","rightChannelBuffer","channelIndex","hasMore","sampleCache","beatLength","patternIndex","sequenceIndex","localStorage","JSON","stringify","musicPlaying","bgmusicnode","loop","sound","gain","linearRampToValueAtTime","currentTime","MouseAdapter","ATTACK","RELOAD","pointer","clientX","clientY","button","preventDefault","releaseRMBTick","lt","ot","at","ft","ut","bt","Ht","ct","kt","Rt","pressed","released","framesHeld","init","update","Map","MapLoader","Gt","rooms","reduce","hash","roomNumber","Wt","pattern","ptr","next","roomLookup","createRoomLookup","R","createWalls","jt","C_SHIFT","10","32","33","39","44","46","73","C_ICONS","Text","white","icons","icon","black","recolor","black_shadow","blue","blue_shadow","red","charCodeAt","C_WIDTH","cu","cv","phrases","split","phrase","phraseWidth","measureWidth","drawText","Ft","sum","color","ScreenShake","frames","hAmplitude","vAmplitude","hSamples","vSamples","sampleCount","frame","s0","s1","decay","ShotgunBlast","spread","range","screenshakes","cull","entities","filter","entity","hp","vect","radius","dot1","dot2","sides","wallHit","tile","ei","ri","ni","ReloadAnimation","shellsMax","end","play","Gore","vel","noClipEntity","bounce","drawViewportSprite","spray","kill","count","lastDamage","SpawnAnimation","chars","uv","Hud","shellsLeft","pages","victory","deaths","pageGlow","padStart","drawPageArrow","closestPage","xy","sort","PageCollectedAnimation","amount","Page","baseFrame","Player","history","facing","forcedReload","mass","baseSpeed","unshift","splice","blockMove","defaultMovement","blockFire","reload","fire","blockReload","dialogPending","releasePages","started","enemies","velocityAdj","facingAngle","forced","blast","headbob","hf","number","remainder","Stabguts","lastAttack","enemy","Spindoctor","dist","SpawnPatterns","Brawl","livingEnemies","plan","roomsCleared","spawn","shift","qr","L","Ki","vi","expandPattern","entry","Movement","movers","rounds","clipVelocityEntityVsEntity","clipVelocityAgainstWalls","other","hit","r1","v1","r2","v2","delta","entityM","otherM","entityI","otherI","noClipWall","tilesHitByCircle","HealthChunkAnimation","gravity","Damage","knockback","Dialog","key","details","flag","speech","dialogSeen","spriteu","spritev","textu","textv","drawParagraph","Yi","Ni","ki","DialogScheduling","Victory","enemyCount","Maze","offset","q1","q2","fillViewportRect","coords","loadSpritesheet","loadMap","shadowCanvas","shadowOffset","M","pause","unpause","requestAnimationFrame","onFrame","currentms","draw","paused","think","perform","screenshake","monetization","powerup","setTransform","shakeX","shakeY","forEach","shake","title"],"mappings":"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C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,GAA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,GAAI,EAAG,EAAG,EAAG,EAAG,GAClB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,EAAG,GAAI,EAAG,EAAG,GAAI,GACnB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,EAAG,GAAI,EAAG,EAAG,GACf,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,GACrB,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,GACpB,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,IACvB,CAAE,IACA,GACA,GACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,GACA,GACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,GACA,GACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,IAGEC,EAAY,CACdC,GAAiBC,GACNA,EAAMC,OAAO,CAACC,EAAMrO,KACvBqO,EAAKrO,EAAKsO,IAActO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","file":"app.js","sourcesContent":["(function () {\n    'use strict';\n\n    // The game's desired dimensions in pixels - the actual dimensions can be adjusted\n    // slightly by the Viewport module.\n    const GAME_WIDTH  = 480;\n    const GAME_HEIGHT = 270;\n\n    // Size in pixels of each map tile\n    const TILE_SIZE   = 32;\n\n    // Bitmasks used to represent wall sides on map\n    const WALL_TOP    = 0b0000_0001;\n    const WALL_RIGHT  = 0b0000_0010;\n    const WALL_BOTTOM = 0b0000_0100;\n    const WALL_LEFT   = 0b0000_1000;\n\n    // Bitmasks used to represent \"doorways\" on map (these doorways are blocked\n    // during a brawl.)\n    const OPEN_TOP    = 0b0001_0000;\n    const OPEN_RIGHT  = 0b0010_0000;\n    const OPEN_BOTTOM = 0b0100_0000;\n    const OPEN_LEFT   = 0b1000_0000;\n    const ROOM_ENDING = 25;\n\n    // Coordinates of the page count on the HUD (used by multiple modules since\n    // there is a little \"page collected\" animation).\n    const HUD_PAGE_U  = 47;\n    const HUD_PAGE_V  = 2;\n    const HUD_PAGE_TEXT_U = 34;\n\n    // Handy IDs to represent the different dialog boxes / speech bubbles that can\n    // appear during the game.\n    const DIALOG_START_A    = 0;\n    const DIALOG_START_B    = 1;\n    const DIALOG_HINT_1     = 2;\n    const DIALOG_HINT_2     = 3;\n    const DIALOG_HINT_3     = 4;\n    const DIALOG_HINT_DEATH = 5;\n    const DIALOG_HINT_E1    = 6;\n    const DIALOG_HINT_E2    = 7;\n    const DIALOG_HINT_DMG   = 8;\n\n    // Some pre-calculated radian values\n    const R0          =   0;\n    const R6          =   6 * Math.PI / 180;\n    const R20         =  20 * Math.PI / 180;\n    const R45         =  45 * Math.PI / 180;\n    const R70         =  70 * Math.PI / 180;\n    const R72         =  72 * Math.PI / 180;\n    const R80         =  80 * Math.PI / 180;\n    const R90         =  90 * Math.PI / 180;\n    const R360        = 360 * Math.PI / 180;\n\n    /**\n     * Viewport\n     *\n     * Represents the game display (for us, a canvas).\n     */\n    const Viewport = {\n        init() {\n            Viewport.canvas = document.getElementById('canvas');\n            Viewport.ctx = Viewport.canvas.getContext('2d');\n            Viewport.resize(true);\n        },\n\n        // Resize the canvas to give us approximately our desired game display size.\n        //\n        // Rather than attempt to explain it, here's a concrete example:\n        //\n        //     we start with a desired game dimension:   480x270px\n        //          get the actual browser dimensions:  1309x468px\n        //          factor in the display's DPI ratio:  2618x936px\n        //         now calculate the horizontal scale:       5.45x\n        //                     and the vertical scale:       3.46x\n        //            our new offical game scaling is:        5.4x\n        //       and our official viewport dimensions:   484x173px\n        //\n        // This approach emphasizes correct aspect ratio and maintains full-window rendering, at\n        // the potential cost of limiting visibility of the game itself in either the X or Y axis.\n        // If you use this approach, make sure your GUI can \"float\" (otherwise there may be whole\n        // UI elements the player cannot see!).\n        resize(force) {\n            let dpi = window.devicePixelRatio,\n                width = Viewport.canvas.clientWidth,\n                height = Viewport.canvas.clientHeight,\n                dpiWidth = width * dpi,\n                dpiHeight = height * dpi;\n\n            if (\n                force ||\n                Viewport.canvas.width !== dpiWidth ||\n                Viewport.canvas.height !== dpiHeight\n            ) {\n                Viewport.canvas.width = dpiWidth;\n                Viewport.canvas.height = dpiHeight;\n\n                Viewport.scale = ((Math.max(dpiWidth / GAME_WIDTH, dpiHeight / GAME_HEIGHT) * 10) | 0) / 10;\n                Viewport.width = Math.ceil(dpiWidth / Viewport.scale);\n                Viewport.height = Math.ceil(dpiHeight / Viewport.scale);\n                Viewport.center = {\n                    u: (Viewport.width / 2) | 0,\n                    v: (Viewport.height / 2) | 0\n                };\n                Viewport.clientWidth = width;\n                Viewport.clientHeight = height;\n\n                // Note: smoothing flag gets reset on every resize by some browsers, which is why\n                // we do it here.\n                Viewport.ctx.imageSmoothingEnabled = false;\n            }\n\n            // We do this every frame, not just on resize, due to browser sometimes \"forgetting\".\n            Viewport.canvas.style.cursor = 'none';\n        },\n\n        fillViewportRect() {\n            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);\n        }\n    };\n\n    function normalizeVector(p) {\n        let m = Math.sqrt(p.x * p.x + p.y * p.y);\n        return m === 0 ? { x: 0, y: 0, m: 0 } : { x: p.x / m, y: p.y / m, m };\n    }\n\n    function vectorBetween(p1, p2) {\n        return normalizeVector({ x: p2.x - p1.x, y: p2.y - p1.y });\n    }\n\n    function angle2vector(r, m) {\n        return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };\n    }\n\n    function vector2angle(v) {\n        let angle = Math.atan2(v.y, v.x);\n        if (angle < 0) angle += R360;\n        return angle;\n    }\n\n    function vector2point(v) {\n        return { x: v.x * (v.m || 1), y: v.y * (v.m || 1) };\n    }\n\n    // Takes a series of vectors and denormalizes them and adds them together, usually resulting\n    // in a point in space. Wrap in normalizeVector to get a normalized vector again, if desired.\n    function vectorAdd(...vectors) {\n        let v = { x: 0, y: 0, m: 1 };\n        for (let vector of vectors) {\n            v.x += vector.x * (vector.m || 1);\n            v.y += vector.y * (vector.m || 1);\n        }\n        return v;\n    }\n\n    function arcOverlap(angleA1, angleA2, angleB1, angleB2) {\n        if (angleA1 > angleA2) [angleA1, angleA2] = [angleA2, angleA1];\n        if (angleB1 > angleB2) [angleB1, angleB2] = [angleB2, angleB1];\n\n        while (angleB2 >= angleA2 + R360) {\n            angleB2 -= R360;\n            angleB1 -= R360;\n        }\n        while (angleB1 <= angleA1 - R360) {\n            angleB1 += R360;\n            angleB2 += R360;\n        }\n\n        const result = [Math.max(angleA1, angleB1), Math.min(angleA2, angleB2)];\n        return result[0] > result[1] ? undefined : result;\n    }\n\n    function xy2qr(pos) {\n        return { q: (pos.x / TILE_SIZE) | 0, r: (pos.y / TILE_SIZE) | 0 };\n    }\n\n    function qr2xy(pos) {\n        return { x: pos.q * TILE_SIZE, y: pos.r * TILE_SIZE };\n    }\n\n    function xy2uv(pos) {\n        return {\n            u: pos.x + Viewport.center.u - game.camera.pos.x,\n            v: pos.y + Viewport.center.v - game.camera.pos.y\n        };\n    }\n\n    function uv2xy(pos) {\n        return {\n            x: pos.u - Viewport.center.u + game.camera.pos.x,\n            y: pos.v - Viewport.center.v + game.camera.pos.y\n        };\n    }\n\n    function clamp(value, min, max) {\n        return value < min ? min : value > max ? max : value;\n    }\n\n    // The parameters to this function are (Q, Q) or (R, R) - i.e. horizontal or\n    // vertical coordinates in tile space.\n    function calculateRayIntersectionAndStep(startPos, endPos) {\n        let _next,\n            _step,\n            diff = endPos - startPos;\n\n        if (diff === 0) {\n            _step = NaN;\n            _next = +Infinity;\n        } else if (diff > 0) {\n            _step = 1 / diff;\n            _next = (1 - (startPos - (startPos | 0))) * _step;\n        } else {\n            _step = -1 / diff;\n            _next = (startPos - (startPos | 0)) * _step;\n        }\n\n        return { _next, _step };\n    }\n\n    // https://www.genericgamedev.com/general/shooting-rays-through-tilemaps/\n    function* tilesHitBetween(p1, p2) {\n        let startQ = p1.x / TILE_SIZE,\n            startR = p1.y / TILE_SIZE;\n        let endQ = p2.x / TILE_SIZE,\n            endR = p2.y / TILE_SIZE;\n        let tileCount =\n            Math.abs((startQ | 0) - (endQ | 0)) +\n            Math.abs((startR | 0) - (endR | 0));\n\n        yield { q: startQ | 0, r: startR | 0, m: 0 };\n\n        // If there's only 1 or 2 hit tiles, we don't need the math to compute the middle.\n        if (tileCount > 1) {\n            let q = startQ,\n                r = startR,\n                m = 0;\n            let stepQ = Math.sign(endQ - startQ);\n            let stepR = Math.sign(endR - startR);\n            let intersectionQ = calculateRayIntersectionAndStep(startQ, endQ);\n            let intersectionR = calculateRayIntersectionAndStep(startR, endR);\n\n            for (let i = 0; i < tileCount - 1; i++) {\n                if (intersectionQ._next < intersectionR._next) {\n                    q += stepQ;\n                    m += stepQ;\n                    intersectionQ._next += intersectionQ._step;\n                } else {\n                    r += stepR;\n                    m += stepR;\n                    intersectionR._next += intersectionR._step;\n                }\n                yield { q: q | 0, r: r | 0, m };\n            }\n        }\n\n        if (tileCount > 0) {\n            yield { q: endQ | 0, r: endR | 0, m: 1 };\n        }\n    }\n\n    function* tilesHitBy(p, v) {\n        yield* tilesHitBetween(p, vectorAdd(p, v));\n    }\n\n    /**\n     * @param {XY[]} bounds  the upper-left and lower-right bounds\n     * @yields {QR}\n     */\n    function* tilesHitInBounds(bounds) {\n        for (let r = bounds[0].y / TILE_SIZE | 0; r * TILE_SIZE < bounds[1].y; r++) {\n            for (let q = bounds[0].x / TILE_SIZE | 0; q * TILE_SIZE <  bounds[1].x; q++) {\n                yield { q, r };\n            }\n        }\n    }\n\n    /**\n     * @param {XY} p1  the starting position\n     * @param {XY} p2  the ending position\n     * @param {number} r  the radius of the moving circle\n     * @yields {QR}\n     */\n    function* tilesHitBetweenCircle(p1, p2, r) {\n        let bounds = [\n            { x: Math.min(p1.x, p2.x) - r, y: Math.min(p1.y, p2.y) - r },\n            { x: Math.max(p1.x, p2.x) + r, y: Math.max(p1.y, p2.y) + r }\n        ];\n        yield* tilesHitInBounds(bounds);\n    }\n\n    /**\n     * @param {XY} p  the starting position\n     * @param {XY} v  the velocity (movement)\n     * @param {number} r  the radius of the moving circle\n     * @yields {QR}\n     */\n    function* tilesHitByCircle(p, v, r) {\n        yield* tilesHitBetweenCircle(p, { x: p.x + v.x, y: p.y + v.y }, r);\n    }\n\n    // See https://stackoverflow.com/a/18790389/80630\n    function intersectCircleRectangle(p1, p2, r, bounds) {\n        // If the bounding box around the start and end points (+radius on all\n        // sides) does not intersect with the rectangle, definitely not an\n        // intersection\n        if (\n            Math.max(p1.x, p2.x) + r < bounds[0].x ||\n            Math.min(p1.x, p2.x) - r > bounds[1].x ||\n            Math.max(p1.y, p2.y) + r < bounds[0].y ||\n            Math.min(p1.y, p2.y) - r > bounds[1].y\n        )\n            return;\n\n        let dx = p2.x - p1.x;\n        let dy = p2.y - p1.y;\n        let invdx = dx === 0 ? 0 : 1 / dx;\n        let invdy = dy === 0 ? 0 : 1 / dy;\n        let cornerX = Infinity;\n        let cornerY = Infinity;\n\n        // Check each side of the rectangle for a single-side intersection\n        // Left Side\n        if (p1.x - r < bounds[0].x && p2.x + r > bounds[0].x) {\n            let ltime = (bounds[0].x - r - p1.x) * invdx;\n            if (ltime >= 0 && ltime <= 1) {\n                let ly = dy * ltime + p1.y;\n                if (ly >= bounds[0].y && ly <= bounds[1].y) {\n                    return {\n                        x: dx * ltime + p1.x,\n                        y: ly,\n                        t: ltime,\n                        nx: -1,\n                        ny: 0,\n                        ix: bounds[0].x,\n                        iy: ly\n                    };\n                }\n            }\n            cornerX = bounds[0].x;\n        }\n        // Right Side\n        if (p1.x + r > bounds[1].x && p2.x - r < bounds[1].x) {\n            let rtime = (p1.x - (bounds[1].x + r)) * -invdx;\n            if (rtime >= 0 && rtime <= 1) {\n                let ry = dy * rtime + p2.y;\n                if (ry >= bounds[0].y && ry <= bounds[1].y) {\n                    return {\n                        x: dx * rtime + p1.x,\n                        y: ry,\n                        t: rtime,\n                        nx: 1,\n                        ny: 0,\n                        ix: bounds[1].x,\n                        iy: ry\n                    };\n                }\n            }\n            cornerX = bounds[1].x;\n        }\n        // Top Side\n        if (p1.y - r < bounds[0].y && p2.y + r > bounds[0].y) {\n            let ttime = (bounds[0].y - r - p1.y) * invdy;\n            if (ttime >= 0 && ttime <= 1) {\n                let tx = dx * ttime + p1.x;\n                if (tx >= bounds[0].x && tx <= bounds[1].x) {\n                    return {\n                        x: tx,\n                        y: dy * ttime + p1.y,\n                        t: ttime,\n                        nx: 0,\n                        ny: -1,\n                        ix: tx,\n                        iy: bounds[0].y\n                    };\n                }\n            }\n            cornerY = bounds[0].y;\n        }\n        // Bottom Side\n        if (p1.y + r > bounds[1].y && p2.y - r < bounds[1].y) {\n            let btime = (p1.y - (bounds[1].y + r)) * -invdy;\n            if (btime >= 0 && btime <= 1) {\n                let bx = dx * btime + p1.x;\n                if (bx >= bounds[0].x && bx <= bounds[1].x) {\n                    return {\n                        x: bx,\n                        y: dy * btime + p1.y,\n                        t: btime,\n                        nx: 0,\n                        ny: 1,\n                        ix: bx,\n                        iy: bounds[0].y\n                    };\n                }\n            }\n            cornerY = bounds[1].y;\n        }\n\n        // If we haven't touched anything, there is no collision\n        if (cornerX === Infinity && cornerY === Infinity) return;\n\n        // We didn't pass through a side but may be hitting the corner\n        if (cornerX !== Infinity && cornerY === Infinity) {\n            cornerY = dy > 0 ? bounds[1].y : bounds[0].y;\n        }\n        if (cornerY !== Infinity && cornerX === Infinity) {\n            cornerX = dx > 0 ? bounds[1].x : bounds[0].x;\n        }\n\n        /* Solve the triangle between the start, corner, and intersection point.\n         *\n         *           +-----------T-----------+\n         *           |                       |\n         *          L|                       |R\n         *           |                       |\n         *           C-----------B-----------+\n         *          / \\\n         *         /   \\r     _.-E\n         *        /     \\ _.-'\n         *       /    _.-I\n         *      / _.-'\n         *     S-'\n         *\n         * S = start of circle's path\n         * E = end of circle's path\n         * LTRB = sides of the rectangle\n         * I = {ix, iY} = point at which the circle intersects with the rectangle\n         * C = corner of intersection (and collision point)\n         * C=>I (r) = {nx, ny} = radius and intersection normal\n         * S=>C = cornerdist\n         * S=>I = intersectionDistance\n         * S=>E = lineLength\n         * <S = innerAngle\n         * <I = angle1\n         * <C = angle2\n         */\n        let inverseRadius = 1 / r;\n        let lineLength = Math.sqrt(dx * dx + dy * dy);\n        let cornerdx = cornerX - p1.x;\n        let cornerdy = cornerY - p1.y;\n        let cornerDistance = Math.sqrt(cornerdx * cornerdx + cornerdy * cornerdy);\n        let innerAngle = Math.acos(\n            (cornerdx * dx + cornerdy * dy) / (lineLength * cornerDistance)\n        );\n\n        // If the circle is too close, no intersection\n        if (cornerDistance < r) return;\n\n        // If inner angle is zero, it's going to hit the corner straight on.\n        if (innerAngle === 0) {\n            let time = (cornerDistance - r) / lineLength;\n\n            // Ignore if time is outside boundaries of (p1, p2)\n            if (time > 1 || time < 0) return;\n\n            let ix = time * dx + p1.x;\n            let iy = time * dy + p1.y;\n            let nx = cornerdx / cornerDistance;\n            let ny = cornerdy / cornerDistance;\n\n            return isNaN(ix)\n                ? undefined\n                : { x: ix, y: iy, t: time, nx, ny, ix: cornerX, iy: cornerY };\n        }\n\n        let innerAngleSin = Math.sin(innerAngle);\n        let angle1Sin = innerAngleSin * cornerDistance * inverseRadius;\n\n        // If the angle is too large, there is no collision\n        if (Math.abs(angle1Sin) > 1) return;\n\n        let angle1 = Math.PI - Math.asin(angle1Sin);\n        let angle2 = Math.PI - innerAngle - angle1;\n        let intersectionDistance = (r * Math.sin(angle2)) / innerAngleSin;\n        let time = intersectionDistance / lineLength;\n\n        // Ignore if time is outside boundaries of (p1, p2)\n        if (time > 1 || time < 0) return;\n\n        let ix = time * dx + p1.x;\n        let iy = time * dy + p2.y;\n        let nx = (ix - cornerX) * inverseRadius;\n        let ny = (iy - cornerY) * inverseRadius;\n\n        return isNaN(ix)\n            ? undefined\n            : { x: ix, y: iy, t: time, nx, ny, ix: cornerX, iy: cornerY };\n    }\n\n    // https://stackoverflow.com/questions/18683179/how-to-fix-circles-overlap-in-collision-response\n    //\n    // This is an incredibly simple implementation that ASSUMES very small velocities. It doesn't attempt\n    // to answer the question about \"when\" the intersection happened like the method above - may\n    // fix that in future.\n    function intersectCircleCircle(p1, r1, v1, p2, r2, v2) {\n        [v1, v2] = [vector2point(v1), vector2point(v2)];\n        let a1 = { x: p1.x + v1.x, y: p1.y + v1.y };\n        let a2 = { x: p2.x + v2.x, y: p2.y + v2.y };\n        let delta = vectorBetween(a1, a2);\n        if (delta.m < r1 + r2) {\n            return { nx: delta.x, ny: delta.y, m: r1 + r2 - delta.m };\n        }\n    }\n\n    function array2d(width, height, fn) {\n        return Array.from({ length: height }, () =>\n            Array.from({ length: width }, fn)\n        );\n    }\n\n    function tileIsPassable(q, r) {\n        if (game.brawl) {\n            let room = game.brawl.room;\n            if (\n                q < room.q ||\n                r < room.r ||\n                q >= room.q + room.w ||\n                r >= room.r + room.h\n            )\n                return false;\n        }\n        if (q < 0 || r < 0 || q >= game.maze.w || r >= game.maze.h) return false;\n        return !!game.maze.maze[r][q];\n    }\n\n    function rgba(r, g, b, a) {\n        return `rgba(${r},${g},${b},${a})`;\n    }\n\n    function createCanvas(width, height) {\n        let canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        let ctx = canvas.getContext('2d');\n        return { canvas, ctx };\n    }\n\n    function roomCenter(room) {\n        return {\n            x: (room.q + room.w / 2) * TILE_SIZE,\n            y: (room.r + room.h / 2) * TILE_SIZE\n        };\n    }\n\n    function partialText(text, t, d) {\n        let length = clamp(Math.ceil(t / d * text.length), 0, text.length),\n            substr = text.slice(0, length),\n            idx = text.indexOf(' ', length - 1);\n        if (idx < 0) idx = text.length;\n        if (idx - length > 0) substr += '#'.repeat(idx - length);\n\n        return substr;\n    }\n\n    /**\n     * This module is generated by `gulp buildAssets`.\n     */\n    const SpriteSheet =\n        /* <generated> */\n    { dialog: [ [ 0, 0, 15, 15 ], [ 15, 0, 15, 15 ], [ 30, 0, 15, 15 ] ],\n      font: [ [ 0, 15, 180, 12 ] ],\n      gore: [ [ 0, 27, 5, 5 ], [ 5, 27, 5, 5 ], [ 10, 27, 5, 5 ], [ 15, 27, 5, 5 ] ],\n      hud_crosshair: [ [ 0, 32, 9, 9 ] ],\n      hud_healthbar: [ [ 0, 41, 109, 9 ], [ 109, 41, 109, 9 ] ],\n      hud_shells: [ [ 0, 50, 6, 7 ], [ 6, 50, 6, 7 ] ],\n      icon_mouse: [ [ 0, 57, 7, 9 ], [ 7, 57, 7, 9 ] ],\n      page: [ [ 0, 66, 12, 14 ], [ 12, 66, 12, 14 ], [ 24, 66, 12, 14 ] ],\n      player: [ [ 0, 80, 21, 32 ], [ 21, 80, 21, 32 ], [ 42, 80, 21, 32 ] ],\n      shotgun_blast:\n       [ [ 0, 112, 23, 18 ], [ 23, 112, 23, 18 ], [ 46, 112, 23, 18 ], [ 69, 112, 23, 18 ] ],\n      spindoctor: [ [ 0, 130, 17, 17 ], [ 17, 130, 17, 17 ] ],\n      stabguts:\n       [ [ 0, 147, 14, 22 ], [ 14, 147, 14, 22 ], [ 28, 147, 14, 22 ], [ 42, 147, 14, 22 ] ],\n      tiles: [ [ 0, 169, 32, 32 ] ],\n      walls: [ [ 0, 201, 4, 4 ], [ 4, 201, 4, 4 ] ],\n      base64:\n       'data:image/png;base64,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' };\n    /* </generated> */\n\n    /**\n     * Sprite\n     *\n     * Encapsulates loading sprite slices from the spritesheet, organizing them, and\n     * modifying them or constructing using primitives. To save space, we use some techniques\n     * like storing only a small slice of an image in the spritesheet, then using code\n     * to duplicate it, add some randomness, etc.\n     */\n    const Sprite = {\n        // This is an exception to the rule, loading the spritesheet is a special action that\n        // happens BEFORE everything is initialized.\n        loadSpritesheet(cb) {\n            let image = new Image();\n            image.onload = cb;\n            image.src = SpriteSheet.base64;\n            Sprite.sheet = image;\n        },\n\n        init() {\n            // Base pixel font and icons (see `Text.init` for additional variations)\n            Sprite.font = initBasicSprite(SpriteSheet.font[0]);\n            Sprite.icon_mouse_lmb = initBasicSprite(SpriteSheet.icon_mouse[0]);\n            Sprite.icon_mouse_rmb = initBasicSprite(SpriteSheet.icon_mouse[1]);\n\n            // Player\n            Sprite.player = SpriteSheet.player.map(data =>\n                initBasicSprite(data, { x: 10, y: 21 })\n            );\n            Sprite.shotgun_blast = SpriteSheet.shotgun_blast.map(data =>\n                initBasicSprite(data, { x: 11, y: 14 })\n            );\n\n            // Enemies\n            Sprite.stabguts = SpriteSheet.stabguts.map(initBasicSprite);\n            Sprite.spindoctor = SpriteSheet.spindoctor.map(initBasicSprite);\n\n            // Gore/blood\n            Sprite.gore = SpriteSheet.gore.map(initBasicSprite);\n\n            // GUI\n            Sprite.hud_shells_empty = initBasicSprite(SpriteSheet.hud_shells[0]);\n            Sprite.hud_shells_full = initBasicSprite(SpriteSheet.hud_shells[1]);\n            Sprite.hud_healthbar = SpriteSheet.hud_healthbar.map(initBasicSprite);\n            Sprite.hud_healthbar.push(initDynamicSprite(createHealthChunk(Sprite.hud_healthbar[1].img)));\n            Sprite.hud_crosshair = SpriteSheet.hud_crosshair.map(initBasicSprite);\n\n            // Pages\n            Sprite.page = SpriteSheet.page.map(initBasicSprite);\n\n            // Tiles\n            Sprite.tiles = SpriteSheet.tiles.map(initBasicSprite);\n            Sprite.tiles[1] = initDynamicSprite(createSecondTile(Sprite.tiles[0].img));\n            Sprite.tilebg = initDynamicSprite(createTileBg(Sprite.tiles[0].img));\n            Sprite.shadow = initDynamicSprite(createShadow());\n\n            // Walls/gates (gates are openings that close during brawls)\n            let w = SpriteSheet.walls.map(initBasicSprite);\n            Sprite.walls = initDynamicSprite(createWalls(w[0].img));\n            Sprite.gates = initDynamicSprite(createGates(w[0].img, w[1].img));\n\n            // Dialog\n            let dialog = SpriteSheet.dialog.map(initBasicSprite);\n            Sprite.dialog_speech = initDynamicSprite(createDialogSpeech(dialog[0].img, dialog[2].img));\n            Sprite.dialog_hint = initDynamicSprite(createDialogHint(dialog[1].img));\n        },\n\n        /**\n         * A small helper that draws a sprite onto a canvas, respecting the anchor point of\n         * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if\n         * that's appropriate!\n         */\n        drawSprite(ctx, sprite, u, v) {\n            ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);\n        },\n\n        drawViewportSprite(sprite, pos, rotation) {\n            let { u, v } = this.viewportSprite2uv(\n                sprite,\n                pos\n            );\n            if (rotation) {\n                Viewport.ctx.save();\n                Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);\n                Viewport.ctx.rotate(rotation);\n                Viewport.ctx.drawImage(\n                    sprite.img,\n                    -sprite.anchor.x,\n                    -sprite.anchor.y\n                );\n                Viewport.ctx.restore();\n            } else {\n                Viewport.ctx.drawImage(sprite.img, u, v);\n            }\n        },\n\n        viewportSprite2uv(sprite, pos) {\n            return {\n                u: pos.x - sprite.anchor.x - game.camera.pos.x + Viewport.center.u,\n                v: pos.y - sprite.anchor.y - game.camera.pos.y + Viewport.center.v\n            };\n        }\n    };\n\n    // Sprite utility functions\n\n    function initBasicSprite(data, anchor) {\n        return initDynamicSprite(loadCacheSlice(...data), anchor);\n    }\n\n    function initDynamicSprite(source, anchor) {\n        let w = source.width,\n            h = source.height;\n\n        return {\n            img: source,\n            // Hack! Using a flat `.map(initBasicSprite)` is actually going to pass the\n            // element INDEX as second argument, resulting in \"anchor=1\". The right solution\n            // here is \"typeof anchor === 'object' ?\", but to save bytes I avoid using\n            // the typeof and instanceof keywords anywhere in the codebase. Hence,\n            // \"anchor && anchor.x\".\n            anchor: (anchor && anchor.x) ? anchor : { x: (w / 2) | 0, y: (h / 2) | 0 }\n        };\n    }\n\n    function loadCacheSlice(x, y, w, h) {\n        const source = Sprite.sheet;\n        const sliceCanvas = createCanvas(w, h);\n        sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);\n        return sliceCanvas.canvas;\n    }\n\n    // Create the 36x36 \"walls\" tile rendered between walls and flors\n    function createWalls(source) {\n        let canvas = createCanvas(36, 36);\n        for (let i = 0; i < 36; i += 4) {\n            canvas.ctx.drawImage(source, i, 0);\n            canvas.ctx.drawImage(source, i, 32);\n            canvas.ctx.drawImage(source, 0, i);\n            canvas.ctx.drawImage(source, 32, i);\n        }\n        addNoise(canvas);\n        return canvas.canvas;\n    }\n\n    // Create the 36x36 \"prison gates\" tile for use during brawls\n    function createGates(wallSource, spikeSource) {\n        let canvas = createCanvas(36, 36);\n        for (let i = 0; i < 36; i += 4) {\n            canvas.ctx.drawImage(spikeSource, i, 0);\n            canvas.ctx.drawImage(spikeSource, i, 32);\n            canvas.ctx.drawImage(spikeSource, 0, i);\n            canvas.ctx.drawImage(spikeSource, 32, i);\n        }\n        canvas.ctx.drawImage(wallSource, 0, 0);\n        canvas.ctx.drawImage(wallSource, 32, 0);\n        canvas.ctx.drawImage(wallSource, 0, 32);\n        canvas.ctx.drawImage(wallSource, 32, 32);\n        addNoise(canvas);\n        return canvas.canvas;\n    }\n\n    // Add some chunky noise pixels to a wip canvas\n    function addNoise(canvas) {\n        canvas.ctx.globalCompositeOperation = 'source-atop';\n        for (let y = 0; y < 36; y++) {\n            for (let x = 0; x < 36; x++) {\n                canvas.ctx.fillStyle = rgba(0, 0, 0, Math.random() * 0.6);\n                canvas.ctx.fillRect(x, y, 1, 1);\n            }\n        }\n    }\n\n    // Given wall tile, create a full screen tiled version to render in background\n    function createTileBg(source) {\n        let canvas = createCanvas(544, 334);\n        for (let y = 0; y < 334; y += 32) {\n            for (let x = 0; x < 544; x += 32) {\n                canvas.ctx.drawImage(source, x, y);\n            }\n        }\n        return canvas.canvas;\n    }\n\n    // \"Shadow\" overlay (gives flickering shadows in corners)\n    function createShadow() {\n        let canvas = createCanvas(500, 500);\n        let gradient = canvas.ctx.createRadialGradient(\n            250,\n            250,\n            0,\n            250,\n            250,\n            250\n        );\n        gradient.addColorStop(0.3, rgba(0, 0, 0, 0));\n        gradient.addColorStop(1, rgba(0, 0, 0, 0.9));\n        canvas.ctx.fillStyle = gradient;\n        canvas.ctx.fillRect(0, 0, 500, 500);\n        return canvas.canvas;\n    }\n\n    // \"Speech\" bubble (character talking)\n    function createDialogSpeech(source, tail) {\n        let canvas = createCanvas(130, 45);\n        canvas.ctx.drawImage(expandNineTile(source).canvas, 0, 5);\n        canvas.ctx.drawImage(tail, 5, 0);\n        return canvas.canvas;\n    }\n\n    // \"Hint\" dialog (instructional for player)\n    function createDialogHint(source) {\n        let canvas = expandNineTile(source);\n        return canvas.canvas;\n    }\n\n    function expandNineTile(source) {\n        let canvas = createCanvas(130, 40);\n        for (let y = 0; y < 40; y += 5) {\n            for (let x = 0; x < 130; x += 5) {\n                let sx = x === 0 ? 0 : (x === 125 ? 10 : 5);\n                let sy = y === 0 ? 0 : (y === 35 ? 10 : 5);\n                canvas.ctx.drawImage(source, sx, sy, 5, 5, x, y, 5, 5);\n            }\n        }\n        return canvas;\n    }\n\n    // Given the wall tile, do some color manipulation to get a nice floor tile\n    function createSecondTile(source) {\n        let canvas = createCanvas(32, 32);\n        canvas.ctx.fillStyle = rgba(48, 0, 0, 1);\n        canvas.ctx.fillRect(0, 0, 32, 32);\n        canvas.ctx.globalAlpha = 0.6;\n        canvas.ctx.globalCompositeOperation = 'hard-light';\n        canvas.ctx.drawImage(source, 0, 0);\n        addNoise(canvas);\n        return canvas.canvas;\n    }\n\n    // Given the red health bar, make a secondary yellow health bar\n    function createHealthChunk(source) {\n        let canvas = createCanvas(source.width, source.height);\n        canvas.ctx.drawImage(source, 0, 0);\n        canvas.ctx.globalCompositeOperation = 'source-atop';\n        canvas.ctx.fillStyle = rgba(255, 255, 0, 0.6);\n        canvas.ctx.fillRect(0, 0, source.width, source.height);\n        return canvas.canvas;\n    }\n\n    /**\n     * KeyboardAdapter\n     *\n     * Maps keyboard inputs to game inputs.\n     */\n    const KeyboardAdapter = {\n        init() {\n            KeyboardAdapter.map = {\n                KeyW:        Input.Action.UP,\n                KeyA:        Input.Action.LEFT,\n                KeyS:        Input.Action.DOWN,\n                KeyD:        Input.Action.RIGHT,\n                ArrowUp:     Input.Action.UP,\n                ArrowLeft:   Input.Action.LEFT,\n                ArrowDown:   Input.Action.DOWN,\n                ArrowRight:  Input.Action.RIGHT,\n                Escape:      Input.Action.MENU\n            };\n\n            // For keyboard, we support 8-point movement (S, E, SE, etc.)\n            KeyboardAdapter.arrowDirections = [\n                { x:   R0, y:   R0, m: 0 },\n                { x:   R0, y: -R90, m: 1 },\n                { x:   R0, y:  R90, m: 1 },\n                { x:   R0, y:   R0, m: 0 },\n                { x: -R90, y:   R0, m: 1 },\n                { x: -R45, y: -R45, m: 1 },\n                { x: -R45, y:  R45, m: 1 },\n                { x: -R90, y:   R0, m: 1 },\n                { x:  R90, y:   R0, m: 1 },\n                { x:  R45, y: -R45, m: 1 },\n                { x:  R45, y:  R45, m: 1 },\n                { x:  R90, y:   R0, m: 1 },\n                { x:   R0, y:   R0, m: 0 },\n                { x:   R0, y: -R90, m: 1 },\n                { x:   R0, y:  R90, m: 1 },\n                { x:   R0, y:   R0, m: 0 }\n            ];\n\n            KeyboardAdapter.held = [];\n\n            window.addEventListener('keydown', event => {\n                let k = KeyboardAdapter.map[event.code];\n                // Debugging - key presses\n                // console.log(event.key, event.keyCode, event.code, k);\n                if (k) {\n                    KeyboardAdapter.held[k] = true;\n                }\n            });\n\n            window.addEventListener('keyup', event => {\n                let k = KeyboardAdapter.map[event.code];\n                if (k) {\n                    KeyboardAdapter.held[k] = false;\n                }\n            });\n\n            KeyboardAdapter.reset();\n        },\n\n        update() {\n            // For keyboards, we want to convert the state of the various arrow keys being held down\n            // into a directional vector. We use the browser's event to handle the held state of\n            // the other action buttons, so we don't need to process them here.\n            let state =\n                (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +\n                (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +\n                (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +\n                (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);\n\n            KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];\n        },\n\n        reset() {\n            KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[0];\n            for (let action of Object.values(Input.Action)) {\n                KeyboardAdapter.held[action] = false;\n            }\n        }\n    };\n\n    // zzfx() - the universal entry point -- returns a AudioBufferSourceNode\n    const zzfx=(...t)=>zzfxP(zzfxG(...t));\n\n    // zzfxP() - the sound player -- returns a AudioBufferSourceNode\n    const zzfxP=(...t)=>{let e=zzfxX.createBufferSource(),f=zzfxX.createBuffer(t.length,t[0].length,zzfxR);t.map((d,i)=>f.getChannelData(i).set(d)),e.buffer=f,e.connect(zzfx.destination_),e.start();return e};\n\n    // zzfxG() - the sound generator -- returns an array of sample data\n    const zzfxG=(q=1,k=.05,c=220,e=0,t=0,u=.1,r=0,F=1,v=0,z=0,w=0,A=0,l=0,B=0,x=0,G=0,d=0,y=1,m=0,C=0)=>{let b=2*Math.PI,H=v*=500*b/zzfxR**2,I=(0<x?1:-1)*b/4,D=c*=(1+2*k*Math.random()-k)*b/zzfxR,Z=[],g=0,E=0,a=0,n=1,J=0,K=0,f=0,p,h;e=99+zzfxR*e;m*=zzfxR;t*=zzfxR;u*=zzfxR;d*=zzfxR;z*=500*b/zzfxR**3;x*=b/zzfxR;w*=b/zzfxR;A*=zzfxR;l=zzfxR*l|0;for(h=e+m+t+u+d|0;a<h;Z[a++]=f)++K%(100*G|0)||(f=r?1<r?2<r?3<r?Math.sin((g%b)**3):Math.max(Math.min(Math.tan(g),1),-1):1-(2*g/b%2+2)%2:1-4*Math.abs(Math.round(g/b)-g/b):Math.sin(g),f=(l?1-C+C*Math.sin(2*Math.PI*a/l):1)*(0<f?1:-1)*Math.abs(f)**F*q*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-y):a<e+m+t?y:a<h-d?(h-a-d)/u*y:0),f=d?f/2+(d>a?0:(a<h-d?1:(h-a)/d)*Z[a-d|0]/2):f),p=(c+=v+=z)*Math.sin(E*x-I),g+=p-p*B*(1-1E9*(Math.sin(a)+1)%2),E+=p-p*B*(1-1E9*(Math.sin(a)**2+1)%2),n&&++n>A&&(c+=w,D+=w,n=0),!l||++J%l||(c=D,v=H,n=n||1);return Z};\n\n    // zzfxV - global volume\n    const zzfxV=.3;\n\n    // zzfxR - global sample rate\n    const zzfxR=44100;\n\n    // zzfxX - the common audio context\n    const zzfxX=new(top.AudioContext||webkitAudioContext);\n\n    // destination for zzfx and zzfxm sounds\n    zzfx.destination_ = zzfxX.destination;\n\n    /**\n     * ZzFX Music Renderer v2.0.2 by Keith Clark\n     */\n\n    /**\n     * @typedef Channel\n     * @type {Array.<Number>}\n     * @property {Number} 0 - Channel instrument\n     * @property {Number} 1 - Channel panning (-1 to +1)\n     * @property {Number} 2 - Note\n     */\n\n    /**\n     * @typedef Pattern\n     * @type {Array.<Channel>}\n     */\n\n    /**\n     * @typedef Instrument\n     * @type {Array.<Number>} ZzFX sound parameters\n     */\n\n    /**\n     * Generate a song\n     *\n     * @param {Array.<Instrument>} instruments - Array of ZzFX sound paramaters.\n     * @param {Array.<Pattern>} patterns - Array of pattern data.\n     * @param {Array.<Number>} sequence - Array of pattern indexes.\n     * @param {Number} [speed=125] - Playback speed of the song (in BPM).\n     * @returns {Array.<Array.<Number>>} Left and right channel sample data.\n     */\n\n    const zzfxM = (instruments, patterns, sequence, BPM = 125) => {\n        let instrumentParameters,\n            i,\n            j,\n            k,\n            note,\n            sample,\n            patternChannel,\n            notFirstBeat,\n            stop,\n            instrument,\n            pitch,\n            attenuation,\n            outSampleOffset,\n            sampleOffset,\n            nextSampleOffset,\n            sampleBuffer = [],\n            leftChannelBuffer = [],\n            rightChannelBuffer = [],\n            channelIndex = 0,\n            panning,\n            hasMore = 1,\n            sampleCache = {},\n            beatLength = ((zzfxR / BPM) * 60) >> 2;\n\n        // for each channel in order until there are no more\n        for (; hasMore; channelIndex++) {\n            // reset current values\n            sampleBuffer = [(hasMore = notFirstBeat = pitch = outSampleOffset = 0)];\n\n            // for each pattern in sequence\n            sequence.map((patternIndex, sequenceIndex) => {\n                // get pattern for current channel, use empty 1 note pattern if none found\n                patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];\n\n                // check if there are more channels\n                hasMore |= !!patterns[patternIndex][channelIndex];\n\n                // get next offset, use the length of first channel\n                nextSampleOffset =\n                    outSampleOffset +\n                    (patterns[patternIndex][0].length - 2 - !notFirstBeat) *\n                        beatLength;\n\n                // for each beat in pattern, plus one extra if end of sequence\n                for (\n                    i = 2, k = outSampleOffset;\n                    i <\n                    patternChannel.length + (sequenceIndex == sequence.length - 1);\n                    notFirstBeat = ++i\n                ) {\n                    // <channel-note>\n                    note = patternChannel[i];\n\n                    // stop if different instrument or new note\n                    stop = (instrument != (patternChannel[0] || 0)) | note | 0;\n\n                    // fill buffer with samples for previous beat, most cpu intensive part\n                    for (\n                        j = 0;\n                        j < beatLength && notFirstBeat;\n                        // fade off attenuation at end of beat if stopping note, prevents clicking\n                        j++ > beatLength - 99 && stop\n                            ? (attenuation += (attenuation < 1) / 99)\n                            : 0\n                    ) {\n                        // copy sample to stereo buffers with panning\n                        sample =\n                            ((1 - attenuation) * sampleBuffer[sampleOffset++]) /\n                                2 || 0;\n                        leftChannelBuffer[k] =\n                            (leftChannelBuffer[k] || 0) + sample * panning - sample;\n                        rightChannelBuffer[k] =\n                            (rightChannelBuffer[k++] || 0) +\n                            sample * panning +\n                            sample;\n                    }\n\n                    // set up for next note\n                    if (note) {\n                        // set attenuation\n                        attenuation = note % 1;\n                        panning = patternChannel[1] || 0;\n                        if ((note |= 0)) {\n                            // get cached sample\n                            sampleBuffer = sampleCache[\n                                [\n                                    (instrument =\n                                        patternChannel[(sampleOffset = 0)] || 0),\n                                    note\n                                ]\n                            ] =\n                                sampleCache[[instrument, note]] ||\n                                // add sample to cache\n                                ((instrumentParameters = [\n                                    ...instruments[instrument]\n                                ]),\n                                (instrumentParameters[2] *=\n                                    2 ** ((note - 12) / 12)),\n                                zzfxG(...instrumentParameters));\n                        }\n                    }\n                }\n\n                // update the sample offset\n                outSampleOffset = nextSampleOffset;\n            });\n        }\n\n        return [leftChannelBuffer, rightChannelBuffer];\n    };\n\n    const ObliqueMystique = [[[1.3,0,23,,,.2,3,5],[1.5,0,4e3,,,.03,2,1.25,,,,,.02,6.8,-.3,,.5],[.7,0,2100,,,.2,3,3,,,-400,,,2],[,0,655,,,.11,2,1.65,,,,,,3.8,-.1,.1]],[[[,-.5,13,,,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,14,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,14,,,,],[1,.3,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,],[2,1,,,,,,,,,13,,,,,,,,,,,,13,,,,,,,,,,,,,,,,,,,,13,,,,,,,,,,,,13,,,,,,,,,,,,],[,.6,,,,,13,,18,,19,,,,,,,,19,,18,,,,16,,,,13,,,,,,,,,,13,,18,,19,,,,,,,,18,19,18,,,,13,14,13,,16,,18,,19,,],[3,-1,,,13,,,,,,,,,,,,13,,,,,,,,,,,,,,,,,,,,13,,,,,,,,,,,,13,,,,,,,,,,,,,,13,13,13,13]],[[,-.5,13,,,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,14,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,,,13,,,,14,,,,],[1,.3,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,,,13,,13,,13,,13,,13,,],[2,1,,,,,,,,,13,,,,,,,,,,,,13,,,,,,,,,,,,,,,,,,,,13,,,,,,,,,,,,13,,,,,,,,,,,,]]],[1,1,0,0,0,0,1,0],,{}];\n\n    const Audio = {\n        init() {\n            Audio.readyToPlay = false;\n\n            Audio.ctx = zzfxX;\n            Audio.gain_ = Audio.ctx.createGain();\n            Audio.gain_.connect(Audio.ctx.destination);\n            zzfx.destination_ = Audio.gain_;\n\n            Audio.shotgun = [,0.01,140,0.01,0.02,0.45,4,2.42,0.1,-0.1,,,,1.2,,0.3,0.04,0.8,0.02];\n            Audio.page = [,,1233,,.01,.2,1,1.43,,,539,.1,,,,,,.51,.03,.01];\n            Audio.shellReload = [,,68,0.01,,0.14,1,1.53,7.5,0.1,50,0.02,-0.01,-0.2,0.1,0.2,,0.47,0.01];\n            Audio.damage = [,,391,,.19,.01,2,.54,-4,20,,,,,,,.02,.9];\n            Audio.alarm = [,,970,.12,.25,.35,,.39,8.1,,10,.1,.2,,.1,,,.6,.09,.13];\n            Audio.song = zzfxM(...ObliqueMystique);\n\n            // Save our background music in os13k, for fun!\n            localStorage['OS13kMusic,Wizard with a Shotgun - Oblique Mystique'] = JSON.stringify(ObliqueMystique);\n        },\n\n        update() {\n            if (!Audio.readyToPlay) return;\n\n            if (!Audio.musicPlaying) {\n                Audio.bgmusicnode = zzfxP(...Audio.song);\n                Audio.bgmusicnode.loop = true;\n                Audio.musicPlaying = true;\n            }\n        },\n\n        play(sound) {\n            if (!Audio.readyToPlay) return;\n            zzfx(...sound);\n        },\n\n        // It's important we do pausing and unpausing as specific events and not in general update(),\n        // because update() is triggered by the animation frame trigger which does not run if the\n        // page is not visible. (So, if you want the music to fade in the background, for example,\n        // that's not helpful if it won't work because you aren't looking at the page!)\n\n        pause() {\n            Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);\n        },\n\n        unpause() {\n            Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);\n        }\n    };\n\n    /**\n     * MouseAdapter\n     *\n     * Maps mouse inputs to game inputs.\n     */\n    const MouseAdapter = {\n        init() {\n            this.map = [];\n            this.map[0] = Input.Action.ATTACK; // LMB\n            this.map[2] = Input.Action.RELOAD; // RMB\n\n            this.held = [];\n\n            window.addEventListener('mousemove', event => {\n                if (!this.pointer) this.pointer = {};\n                this.pointer.u = ((event.clientX * Viewport.width) / Viewport.clientWidth) | 0;\n                this.pointer.v = ((event.clientY * Viewport.height) / Viewport.clientHeight) | 0;\n            });\n\n            window.addEventListener('mouseout', () => {\n                this.pointer = undefined;\n            });\n\n            window.addEventListener('mousedown', event => {\n                let k = this.map[event.button];\n                if (k) this.held[k] = true;\n\n                // Hack to ensure we initialize audio after user interacts with game\n                Audio.readyToPlay = true;\n            });\n\n            window.addEventListener('mouseup', event => {\n                let k = this.map[event.button];\n                if (k) this.held[k] = false;\n            });\n\n            window.addEventListener('click', event => {\n                event.preventDefault();\n            });\n\n            window.addEventListener('contextmenu', event => {\n                let k = this.map[event.button];\n                if (k) this.held[k] = true;\n                this.releaseRMBTick = 2;\n                event.preventDefault();\n            });\n\n            MouseAdapter.reset();\n        },\n\n        update() {\n            // Hacks: ideally we could use mousedown and mouseup for all clicks and preventDefault to\n            // avoid opening the browser's context menu. This hasn't worked for me so far when clicking\n            // on a canvas, so I need to use the context menu event to capture a right mouse click instead.\n            //\n            // We fake a down/up for RMB clicks, which means we can't determine how long the RMB is held\n            // (but luckily we don't need to for this game).\n            if (this.releaseRMBTick) {\n                this.releaseRMBTick--;\n                if (this.releaseRMBTick === 0) {\n                    this.held[Input.Action.RELOAD] = false;\n                }\n            }\n        },\n\n        reset() {\n            this.pointer = undefined;\n            for (let action of Object.values(Input.Action)) {\n                this.held[action] = false;\n            }\n        }\n    };\n\n    //import { GamepadAdapter } from './GamepadAdapter';\n    //import { NormalVector } from './Geometry';\n\n    /**\n     * This is our abstract game input handler.\n     *\n     * Each frame, we'll collect input data from all of our supported input adapters,\n     * and turn it into game input. This game input can then be used by the game\n     * update for the frame.\n     *\n     * The input adapters give us data like \"key X pressed\", or \"right mouse button\n     * clicked\", or \"button B\" pressed, and these are translated into a game input\n     * like \"dodge\".\n     */\n    const Input = {\n        // Game Inputs\n        //\n        // Note that moving the player around is actually not considered an action; it's\n        // a separate non-action input called \"direction\". It just so happens that on\n        // keyboard, for example, pressing the \"down arrow\" key is considered both a\n        // press of the in-game DOWN action and a directional input. It's up to the input\n        // consumer to decide which input is relevant (if any). For example, on a menu,\n        // we may consume the DOWN/UP actions to navigate the menu, but ignore directional\n        // inputs.\n        //\n        Action: {\n            UP: 11,\n            DOWN: 12,\n            LEFT: 13,\n            RIGHT: 14,\n            ATTACK: 21,\n            RELOAD: 30,\n            MENU: 96,\n            MUTE: 97,\n            FREEZE: 98\n        },\n\n        init() {\n            // A vector representing the direction the user is pressing/facing,\n            // separate from pressing and releasing inputs. Treating \"direction\"\n            // separately makes it easier to handle gamepad sticks.\n            this.direction = { x: 0, y: 0, m: 0 };\n\n            // \"Pressed\" means an input was pressed THIS FRAME.\n            this.pressed = {};\n\n            // \"Released\" means an input was released THIS FRAME.\n            this.released = {};\n\n            // \"Held\" means an input is held down. The input was \"Pressed\" either\n            // this frame or in a past frame, and has not been \"Released\" yet.\n            this.held = {};\n\n            // How many frames was this input held down by the player. If [held]\n            // is false, it represents how long the input was last held down.\n            this.framesHeld = {};\n\n            KeyboardAdapter.init();\n            MouseAdapter.init();\n            //GamepadAdapter.init();\n        },\n\n        update() {\n            // We could have some kind of \"input adapter toggle\", but it's easier to just treat all inputs\n            // as valid -- if you're pressing the \"attack\" button on either gamepad or keyboard, then you're\n            // attacking. For directional input, we instead check whether there's movement on the thumbstick,\n            // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.\n\n            KeyboardAdapter.update();\n            MouseAdapter.update();\n            //GamepadAdapter.update();\n\n            for (let action of Object.values(Input.Action)) {\n                let held = MouseAdapter.held[action] || KeyboardAdapter.held[action];\n                //let held = GamepadAdapter.held[action] || KeyboardAdapter.held[action];\n                this.pressed[action] = !this.held[action] && held;\n                this.released[action] = this.held[action] && !held;\n\n                if (this.pressed[action]) {\n                    this.framesHeld[action] = 1;\n                } else if (this.held[action] && held) {\n                    this.framesHeld[action]++;\n                }\n\n                this.held[action] = held;\n            }\n\n            this.pointer = MouseAdapter.pointer;\n            this.direction = KeyboardAdapter.direction;\n            //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;\n        },\n\n        onDown(action) {},\n        onUp(action) {},\n    };\n\n    /**\n     * This module is generated by `gulp buildAssets`.\n     *\n     * Format is [w, h, rooms, tunnels].\n     */\n    const Map =\n        /* <generated> */\n    [ 41,\n      61,\n      [ [ 24, 1, 5, 4, 5, 3 ],\n        [ 13, 4, 7, 3, 6, 3 ],\n        [ 33, 5, 6, 5, 7, 4 ],\n        [ 23, 7, 5, 5, 8, 2 ],\n        [ 11, 8, 5, 4, 9, 2 ],\n        [ 29, 11, 3, 3, 10, 1 ],\n        [ 18, 12, 4, 7, 11, 3 ],\n        [ 35, 12, 5, 5, 12, 5 ],\n        [ 24, 13, 3, 5, 13, 0 ],\n        [ 7, 14, 3, 5, 14, 0 ],\n        [ 11, 14, 5, 5, 15, 1 ],\n        [ 3, 16, 1, 1, 1 ],\n        [ 23, 20, 5, 5, 16, 3 ],\n        [ 33, 20, 6, 6, 17, 3 ],\n        [ 11, 21, 4, 4, 18, 2 ],\n        [ 18, 21, 3, 3, 19, 1 ],\n        [ 18, 26, 5, 4, 20, 3 ],\n        [ 27, 26, 5, 4, 21, 0 ],\n        [ 10, 27, 6, 4, 22, 3 ],\n        [ 24, 31, 10, 7, 23, 4 ],\n        [ 12, 32, 9, 4, 24, 5 ],\n        [ 10, 51, 12, 9, 25, 0 ] ],\n      [ 231,\n        41,\n        29,\n        4,\n        13,\n        1,\n        27,\n        10,\n        1,\n        1,\n        1,\n        28,\n        1,\n        1,\n        1,\n        1,\n        8,\n        41,\n        7,\n        41,\n        17,\n        12,\n        29,\n        30,\n        1,\n        1,\n        26,\n        12,\n        1,\n        1,\n        1,\n        1,\n        17,\n        1,\n        7,\n        3,\n        1,\n        8,\n        1,\n        2,\n        1,\n        1,\n        4,\n        6,\n        1,\n        12,\n        1,\n        1,\n        2,\n        9,\n        1,\n        1,\n        1,\n        1,\n        24,\n        2,\n        1,\n        1,\n        10,\n        1,\n        1,\n        21,\n        4,\n        1,\n        1,\n        23,\n        6,\n        6,\n        5,\n        24,\n        6,\n        11,\n        41,\n        1,\n        1,\n        30,\n        1,\n        6,\n        1,\n        1,\n        40,\n        41,\n        24,\n        12,\n        5,\n        24,\n        12,\n        40,\n        1,\n        41,\n        1,\n        1,\n        75,\n        10,\n        25,\n        6 ] ];\n    /* </generated> */\n\n    const MapLoader = {\n        createRoomLookup(rooms) {\n            return rooms.reduce((hash, room) => {\n                hash[room.roomNumber] = room;\n                return hash;\n            }, {});\n        },\n\n        createWalls(maze, rooms) {\n            let walls = array2d(maze[0].length, maze.length, () => 0);\n            for (let r = 0; r < walls.length; r++) {\n                for (let q = 0; q < walls[0].length; q++) {\n                    if (maze[r][q]) {\n                        let room = rooms[maze[r][q]];\n\n                        walls[r][q] =\n                            (maze[r - 1][q] ? 0 : WALL_TOP) |\n                            (maze[r][q + 1] ? 0 : WALL_RIGHT) |\n                            (maze[r + 1][q] ? 0 : WALL_BOTTOM) |\n                            (maze[r][q - 1] ? 0 : WALL_LEFT);\n\n                        if (room) {\n                            walls[r][q] |=\n                                (maze[r - 1][q] && r === room.r ? OPEN_TOP : 0) |\n                                (maze[r][q + 1] && (q === room.q + room.w - 1)\n                                    ? OPEN_RIGHT\n                                    : 0) |\n                                (maze[r + 1][q] && (r === room.r + room.h - 1)\n                                    ? OPEN_BOTTOM\n                                    : 0) |\n                                (maze[r][q - 1] && q === room.q ? OPEN_LEFT : 0);\n                        }\n                    }\n                }\n            }\n            return walls;\n        },\n\n        loadMap() {\n            let maze = array2d(Map[0], Map[1], () => 0);\n            let rooms = Map[2].map(room => ({\n                q: room[0],\n                r: room[1],\n                w: room[2],\n                h: room[3],\n                roomNumber: room[4],\n                pattern: room[5]\n            }));\n\n            let ptr = 0;\n            for (let next of Map[3]) {\n                ptr += next;\n                maze[(ptr / Map[0]) | 0][ptr % Map[0]] = 3;\n            }\n\n            for (let room of rooms) {\n                for (let r = 0; r < room.h; r++) {\n                    for (let q = 0; q < room.w; q++) {\n                        maze[room.r + r][room.q + q] = room.roomNumber;\n                    }\n                }\n            }\n\n            let roomLookup = this.createRoomLookup(rooms);\n\n            return {\n                maze,\n                walls: this.createWalls(maze, roomLookup),\n                rooms: roomLookup,\n                w: Map[0],\n                h: Map[1]\n            };\n        }\n    };\n\n    const C_WIDTH = 3;\n    const C_HEIGHT = 5;\n\n    // Very simple variable-width font implementation. The characters in the font strip\n    // are left-aligned in their 3x5 pixel boxes, so in order to have variable width,\n    // we just need to note the characters that AREN'T full width. Anything not in\n    // this list has full shift (3+1 = 4 pixels).\n    const C_SHIFT = {\n        10: 0, // LF (\\n)\n        32: 3, // Space ( )\n        33: 3, // Bang (!)\n        39: 2, // Apostrophe (')\n        44: 3, // Comma (,)\n        46: 3, // Period (.)\n        73: 2 // I\n    };\n\n    const C_ICONS = {};\n\n    /**\n     * Text\n     *\n     * Utilities for drawing text using in-game pixel font.\n     */\n    const Text = {\n        init() {\n            Text.white = Sprite.font.img;\n\n            let icons = [\n                [108, Sprite.icon_mouse_lmb],  // l\n                [114, Sprite.icon_mouse_rmb],  // r\n            ];\n            for (let icon of icons) {\n                C_ICONS[icon[0]] = icon[1];\n                C_SHIFT[icon[0]] = icon[1].img.width + 1;\n            }\n\n            Text.black = recolor(Text.white, rgba(0, 0, 0, 1));\n            Text.black_shadow = recolor(Text.white, rgba(90, 20, 90, 0.15));\n            Text.blue = recolor(Text.white, rgba(200, 40, 220, 1));\n            Text.blue_shadow = recolor(Text.white, rgba(240, 50, 200, 0.2));\n            Text.shadow = recolor(Text.white, rgba(240, 240, 255, 0.25));\n            Text.red = recolor(Text.white, rgba(240, 50, 50, 1));\n        },\n\n        drawText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {\n            for (let idx = 0; idx < text.length; idx++) {\n                let c = text.charCodeAt(idx);\n                if (C_ICONS[c]) {\n                    ctx.drawImage(\n                        C_ICONS[c].img,\n                        u,\n                        v - (C_ICONS[c].img.height - 5) / 2\n                    );\n                } else {\n                    let k = (c - 32) * (C_WIDTH + 1);\n                    if (shadow) {\n                        ctx.drawImage(\n                            shadow,\n                            k % 180,\n                            (k / 180 | 0) * 6,\n                            C_WIDTH,\n                            C_HEIGHT,\n                            u + 1,\n                            v + 1,\n                            C_WIDTH * scale,\n                            C_HEIGHT * scale\n                        );\n                    }\n                    ctx.drawImage(\n                        font,\n                        k % 180,\n                        (k / 180 | 0) * 6,\n                        C_WIDTH,\n                        C_HEIGHT,\n                        u,\n                        v,\n                        C_WIDTH * scale,\n                        C_HEIGHT * scale\n                    );\n                }\n                u += (C_SHIFT[c] || C_WIDTH + 1) * scale;\n            }\n        },\n\n        /*\n        drawRightText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {\n            u -= Text.measureWidth(text, scale);\n            Text.drawText(ctx, text, u, v, scale, font, shadow);\n        },\n        */\n\n        drawParagraph(ctx, text, u, v, w, h, scale = 1, font = Text.white, shadow) {\n            let cu = u,\n                cv = v,\n                phrases = text.split(' ');\n\n            for (let phrase of phrases) {\n                while (phrase[0] === '\\n') {\n                    phrase = phrase.slice(1);\n                    cu = u;\n                    cv += (C_HEIGHT + 2) * scale;\n                }\n                let phraseWidth = Text.measureWidth(phrase, scale);\n                if (cu + phraseWidth - u > w) {\n                    cu = u;\n                    cv += (C_HEIGHT + 2) * scale;\n                }\n                Text.drawText(ctx, phrase, cu, cv, scale, font, shadow);\n                cu += phraseWidth + (C_SHIFT[32] || 4);\n            }\n        },\n\n        measureWidth(text, scale) {\n            return text.split('').reduce((sum, c) => sum + (C_SHIFT[c.charCodeAt(0)] || 4), 0) * scale;\n        }\n    };\n\n    // Text utility functions\n\n\n    function recolor(font, color) {\n        let canvas = createCanvas(font.width, font.height);\n        canvas.ctx.fillStyle = color;\n        canvas.ctx.fillRect(0, 0, font.width, font.height);\n        canvas.ctx.globalCompositeOperation = 'destination-in';\n        canvas.ctx.drawImage(font, 0, 0);\n        return canvas.canvas;\n    }\n\n    // https://jonny.morrill.me/en/blog/gamedev-how-to-implement-a-camera-shake-effect/\n\n    /**\n     * Shake it baby.\n     */\n    class ScreenShake {\n        constructor(frames, hAmplitude, vAmplitude) {\n            this.frames = frames;\n            this.hAmplitude = hAmplitude;\n            this.vAmplitude = vAmplitude;\n            this.hSamples = [];\n            this.vSamples = [];\n\n            var sampleCount = frames / 2;\n            for (let i = 0; i < sampleCount; i++) {\n                this.hSamples.push(Math.random() * 2 - 1);\n                this.vSamples.push(Math.random() * 2 - 1);\n            }\n            this.frame = -1;\n        }\n\n        update() {\n            this.frame++;\n            if (this.frame >= this.frames) {\n                return false;\n            }\n\n            //let s = (this.frames / 10) * (this.frame / this.frames);\n            let s = this.frame / 2;\n            let s0 = s | 0;\n            let s1 = s0 + 1;\n            let decay = 1 - this.frame / this.frames;\n\n            this.x =\n                this.hAmplitude *\n                decay *\n                (this.hSamples[s0] +\n                    (s - s0) * (this.hSamples[s1] - this.hSamples[s0]));\n            this.y =\n                this.vAmplitude *\n                decay *\n                (this.vSamples[s0] +\n                    (s - s0) * (this.vSamples[s1] - this.vSamples[s0]));\n\n            return true;\n        }\n    }\n\n    class ShotgunBlast {\n        constructor(pos, angle) {\n            this.pos = { ...pos };\n            this.angle = angle;\n            this.spread = R80;\n            this.t = -1;\n            this.d = 6;\n            this.range = 55;\n\n            game.screenshakes.push(new ScreenShake(6, 6, 6)); // so metal\n        }\n\n        think() {\n            if (++this.t === this.d) this.cull = true;\n\n            if (this.t === 3) {\n                let entities = game.entities.filter(\n                    entity => entity.hp && entity !== game.player\n                );\n                for (let entity of entities) {\n                    let vect = vectorBetween(this.pos, entity.pos);\n                    if (vect.m >= this.range + entity.radius) continue;\n\n                    let dot1 = vectorBetween(this.pos, {\n                        x: entity.pos.x - vect.y * entity.radius,\n                        y: entity.pos.y + vect.x * entity.radius\n                    });\n                    let dot2 = vectorBetween(this.pos, {\n                        x: entity.pos.x + vect.y * entity.radius,\n                        y: entity.pos.y - vect.x * entity.radius\n                    });\n                    let sides = [vector2angle(dot1), vector2angle(dot2)];\n                    let overlap = arcOverlap(\n                        sides[0],\n                        sides[1],\n                        this.angle - this.spread / 2,\n                        this.angle + this.spread / 2\n                    );\n                    if (!overlap) continue;\n\n                    let wallHit = [];\n                    let k = vectorAdd(this.pos, angle2vector(sides[0], vect.m));\n                    for (let tile of tilesHitBy(\n                        this.pos,\n                        angle2vector(sides[0], vect.m)\n                    )) {\n                        if (!tileIsPassable(tile.q, tile.r)) {\n                            wallHit.push(tile);\n                            break;\n                        }\n                    }\n                    for (let tile of tilesHitBy(\n                        this.pos,\n                        angle2vector(sides[1], vect.m)\n                    )) {\n                        if (!tileIsPassable(tile.q, tile.r)) {\n                            wallHit.push(tile);\n                            break;\n                        }\n                    }\n\n                    if (wallHit.length < 2) {\n                        // hit\n                        entity.damage.push({\n                            amount: 100,\n                            vector: vect,\n                            knockback: vect.m > 32 ? 5 : 10\n                        });\n                    }\n                }\n            }\n        }\n\n        draw() {\n        }\n    }\n\n    /**\n     * Behavior\n     */\n    const CHASE     = 103;\n    const HUNT      = 104;\n    const DEAD      = 106;\n    const SPAWN     = 107;\n    const ATTACK    = 201;\n    const RELOAD    = 202;\n\n    class ReloadAnimation {\n        constructor(frames) {\n            this.t = -1;\n            this.d = frames;\n            this.z = 101;\n        }\n\n        think() {\n            if (++this.t === this.d) this.cull = true;\n        }\n\n        draw() {\n            for (let i = 0; i < game.player.shellsMax; i++) {\n                let end = (i * this.d) / game.player.shellsMax;\n                let start = (end - 3) | 0;\n\n                if (this.t === start) {\n                    Audio.play(Audio.shellReload);\n                }\n                if (this.t >= start) {\n                    let y = Math.min(10, 10 + this.t - end);\n                    Viewport.ctx.globalAlpha = Math.min(1, 1 + (this.t - end) / 10);\n                    Viewport.ctx.drawImage(\n                        Sprite.hud_shells_full.img,\n                        15 + 6 * i,\n                        y\n                    );\n                    Viewport.ctx.globalAlpha = 1;\n                }\n            }\n        }\n    }\n\n    class Gore {\n        constructor(pos, angle, f) {\n            this.pos = { ...pos };\n            this.angle = angle;\n            this.vel = vector2point(angle2vector(this.angle, 5));\n            this.a = R45;\n            this.noClipEntity = true;\n            this.f = f;\n            this.bounce = this.f > -1;\n            this.radius = 1;\n            this.r = 0;\n            this.t = -1;\n            this.d = this.f === 0 ? 45 : 70;\n        }\n\n        think() {\n            if (++this.t === this.d) this.cull = true;\n            this.vel.x *= 0.9;\n            this.vel.y *= 0.9;\n            this.a *= 0.95;\n            this.r += this.a;\n        }\n\n        draw() {\n            Sprite.drawViewportSprite(\n                Sprite.gore[this.f],\n                this.pos,\n                this.r\n            );\n        }\n    }\n\n    Gore.damage = entity => Gore.spray(entity, 8, () => 0);\n    Gore.kill = entity => Gore.spray(entity, 16, () => (Math.random() * 4) | 0);\n    Gore.spray = (entity, count, cb) => {\n        let angle = entity.lastDamage ? vector2angle(entity.lastDamage.vector) : Math.random() * R360;\n\n        for (let i = 0; i < count; i++) {\n            let r = Math.random() * entity.radius,\n                p = vectorAdd(entity.pos, angle2vector(Math.random() * R360, r));\n            game.entities.push(\n                new Gore(p, angle + Math.random() * R90 - R45, cb())\n            );\n        }\n    };\n\n    class SpawnAnimation {\n        constructor(pos) {\n            this.pos = { ...pos };\n            this.t = -1;\n            this.d = 40;\n            this.z = 101;\n        }\n\n        think() {\n            if (++this.t === this.d) this.cull = true;\n        }\n\n        draw() {\n            let chars = ['s', 't', 'u', 'v', 'w'];\n            let uv = xy2uv(this.pos);\n\n            Viewport.ctx.globalAlpha = 1 - (this.t / this.d);\n            for (let i = 0; i < 5; i++) {\n                let v = vector2point(angle2vector(R72 * i + this.t / 36, 12));\n                Text.drawText(Viewport.ctx, chars[i], uv.u + v.x + Math.random() * 2 - 2, uv.v + v.y + Math.random() * 2 - 3, 1, Text.blue, Text.blue_shadow);\n            }\n            Viewport.ctx.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * Hud\n     *\n     * Health bars, ammo, etc.\n     */\n    const Hud = {\n        draw() {\n            // Health\n            let hp = clamp(game.player.hp, 0, 100);\n            Viewport.ctx.drawImage(Sprite.hud_healthbar[0].img, 2, 2);\n            Viewport.ctx.drawImage(\n                Sprite.hud_healthbar[1].img,\n                0, 0, hp + 8, 8,\n                2, 2, hp + 8, 8\n            );\n\n            // Shells\n            let sprite = Sprite.hud_shells_full;\n            for (let i = 0; i < game.player.shellsMax; i++) {\n                if (i + 1 > game.player.shellsLeft)\n                    sprite = Sprite.hud_shells_empty;\n                Viewport.ctx.drawImage(sprite.img, 15 + 6 * i, 10);\n            }\n\n            // Glyphs\n            //Text.drawText(Viewport.ctx, 'stuvw', Viewport.width - HUD_PAGE_TEXT_U - 60, 4, 2, Text.blue, Text.blue_shadow);\n            //if (game.powerup)\n            //    Text.drawText(Viewport.ctx, 'swv', Viewport.width - HUD_PAGE_TEXT_U - 60, 4, 2, Text.blue, Text.blue_shadow);\n\n            // Pages\n            let pages = game.victory ? 666 : game.player.pages;\n            if (pages > 0 || game.player.deaths > 0) {\n                if (Hud.pageGlow > 0 && Hud.pageGlow < 30) {\n                    Viewport.ctx.globalAlpha = 1 - (Hud.pageGlow++ / 60);\n                } else {\n                    Viewport.ctx.globalAlpha = 0.5;\n                }\n                Viewport.ctx.drawImage(\n                    Sprite.page[1].img,\n                    Viewport.width - HUD_PAGE_U,\n                    HUD_PAGE_V\n                );\n                Viewport.ctx.globalAlpha = 1;\n                Viewport.ctx.drawImage(\n                    Sprite.page[0].img,\n                    Viewport.width - HUD_PAGE_U,\n                    HUD_PAGE_V\n                );\n                Text.drawText(\n                    Viewport.ctx,\n                    'x' + ('' + pages).padStart(3, '0'),\n                    Viewport.width - HUD_PAGE_TEXT_U,\n                    4,\n                    2,\n                    game.victory ? Text.red : Text.blue,\n                    Text.blue_shadow\n                );\n            }\n\n            Hud.drawPageArrow();\n\n            // Debugging - viewport width/height\n            /*\n            Text.drawRightText(\n                Viewport.ctx,\n                [Viewport.scale, Viewport.width, Viewport.height, 'stuvwx'].join(', '),\n                Viewport.width - 4,\n                Viewport.height - 18\n            );\n            */\n\n            if (Input.pointer) {\n                if (game.dialog) Viewport.ctx.globalAlpha = 0.5;\n                Sprite.drawViewportSprite(Sprite.hud_crosshair[0], uv2xy(Input.pointer), game.frame / 72);\n                Viewport.ctx.globalAlpha = 1;\n            }\n        },\n\n        drawPageArrow() {\n            let page = Hud.closestPage();\n            if (page) {\n                let vector = vectorBetween(game.player.pos, page.pos);\n                let angle = vector2angle(vector);\n                vector.m = clamp(vector.m / 2, 16, Viewport.height / 2 - 5);\n                if (vector.m > 64) {\n                    let xy = vectorAdd(game.player.pos, vector);\n                    Viewport.ctx.globalAlpha = Math.sin(game.frame / 20) * 0.2 + 0.8;\n                    Sprite.drawViewportSprite(Sprite.page[2], xy, angle + R90);\n                    Viewport.ctx.globalAlpha = 1;\n                }\n            }\n        },\n\n        closestPage() {\n            let pages = game.entities.filter(entity => entity.page);\n            let pos = game.player.pos;\n            pages.sort((a, b) => {\n                let dist = ((a.pos.x - pos.x) ** 2 + (a.pos.y - pos.y) ** 2) - ((b.pos.x - pos.x) ** 2 + (b.pos.y - pos.y) ** 2);\n                return dist;\n            });\n            return pages[0];\n        }\n    };\n\n    class PageCollectedAnimation {\n        constructor(pos, amount) {\n            this.t = -1;\n            this.d = 40;\n            this.z = 101;\n\n            this.a = Sprite.viewportSprite2uv(\n                Sprite.page[0],\n                pos\n            );\n            this.a.u -= Sprite.page[0].anchor.x;\n            this.a.v -= Sprite.page[0].anchor.y;\n            this.b = { u: Viewport.width - HUD_PAGE_U, v: HUD_PAGE_V };\n            this.amount = amount;\n        }\n\n        think() {\n            if (this.t === 10) {\n                Audio.play(Audio.page);\n            }\n\n            if (this.t % 8 === 0) {\n                game.player.hp = clamp(game.player.hp + 1, 0, 100);\n            }\n\n            if (++this.t === this.d) {\n                this.cull = true;\n                game.player.pages += this.amount;\n                Hud.pageGlow = 1;\n            }\n        }\n\n        draw() {\n            let uv = {\n                u: (this.b.u - this.a.u) * this.t / this.d + this.a.u,\n                v: (this.b.v - this.a.v) * this.t / this.d + this.a.v\n            };\n\n            Viewport.ctx.drawImage(Sprite.page[0].img, uv.u, uv.v);\n        }\n    }\n\n    /**\n     * Page\n     */\n    class Page {\n        constructor(pos, amount) {\n            this.pos = { ...pos };\n            this.amount = amount;\n            this.angle = Math.random() * R360;\n            this.vel = vector2point(angle2vector(this.angle, Math.random() * 3 + 1));\n            this.baseFrame = (Math.random() * 60) | 0;\n            //this.mass = 1;\n            this.radius = 3;\n            this.noClipEntity = true;\n            this.page = true;\n            if (game.victory) this.cull = true;\n        }\n\n        think() {\n            this.vel.x *= 0.95;\n            this.vel.y *= 0.95;\n\n            let v = vectorBetween(this.pos, game.player.pos);\n            if (v.m < game.player.radius + this.radius + 2 && game.player.state !== DEAD && game.player.state !== SPAWN) {\n                this.cull = true;\n                game.entities.push(new PageCollectedAnimation(this.pos, this.amount));\n            }\n        }\n\n        draw() {\n            let pos = {\n                x: this.pos.x,\n                y: this.pos.y + Math.sin((game.frame + this.baseFrame) / 30) * 2\n            };\n\n            Sprite.drawViewportSprite(Sprite.page[1], pos);\n            Sprite.drawViewportSprite(Sprite.page[0], pos);\n        }\n    }\n\n    /**\n     * Player\n     */\n    class Player {\n        constructor() {\n            this.pos = roomCenter(game.maze.rooms[1]);\n            this.vel = { x: 0, y: 0 };\n            this.hp = 100;\n            this.damage = [];\n            this.history = [];\n            this.facing = { x: 0, y: -1, m: 0 };\n            this.radius = 11;\n            this.shellsLeft = 4;\n            this.shellsMax = 4;\n            this.forcedReload = false;\n            this.mass = 3;\n            this.pages = 0;\n            this.deaths = 0;\n            this.state = SPAWN;\n            this.frames = 29;\n            this.baseSpeed = 1.7;\n        }\n\n        think() {\n            this.history.unshift({ ...this.pos });\n            this.history.splice(50);\n\n            if (this.state === HUNT) {\n                if (game.dialog && game.dialog.blockMove) {\n                    this.vel = { x: 0, y: 0 };\n                } else {\n                    this.defaultMovement(1);\n                }\n\n                if (!(game.dialog && game.dialog.blockFire)) {\n                    if (Input.pressed[Input.Action.ATTACK]) {\n                        if (this.shellsLeft === 0) {\n                            this.reload();\n                        } else {\n                            this.fire();\n                        }\n                    }\n                }\n\n                if (!(game.dialog && game.dialog.blockReload)) {\n                    if (Input.pressed[Input.Action.RELOAD]) {\n                        if (this.shellsLeft < this.shellsMax) {\n                            this.reload();\n                        }\n                    }\n                }\n\n                if (this.hp < 75) {\n                    game.dialogPending[DIALOG_HINT_DMG] = true;\n                }\n\n                if (this.deaths > 0) {\n                    game.dialogPending[DIALOG_HINT_DEATH] = true;\n                }\n            } else if (this.state === ATTACK) {\n                this.defaultMovement(1);\n                if (--this.frames <= 0) {\n                    if (this.shellsLeft === 0) {\n                        this.reload(true);\n                    } else {\n                        this.state = HUNT;\n                    }\n                }\n            } else if (this.state === RELOAD) {\n                this.defaultMovement(this.forcedReload ? 0.5 : 2.0);\n                if (--this.frames <= 0) {\n                    this.shellsLeft = this.shellsMax;\n                    this.state = HUNT;\n                }\n            } else if (this.state === DEAD) {\n                if (game.victory) {\n                    this.state = HUNT;\n                    game.screenshakes.push(new ScreenShake(15, 15, 25));\n                } else {\n                    this.state = SPAWN;\n                    this.frames = 120;\n                    this.releasePages();\n                }\n                this.hp = 100;\n                this.deaths++;\n                Gore.kill(this);\n                Gore.kill(this);\n            } else if (this.state === SPAWN) {\n                if (game.started) this.frames--;\n                if (this.frames === 30) {\n                    this.pos = roomCenter(game.maze.rooms[1]);\n                    this.vel = { x: 0, y: 0 };\n                    if (game.brawl) {\n                        for (let entity of game.brawl.enemies) {\n                            entity.cull = true;\n                        }\n                        game.brawl = false;\n                    }\n                }\n                if (this.frames === 0) {\n                    this.state = HUNT;\n                    game.entities.push(new SpawnAnimation(this.pos));\n                    game.dialogPending[DIALOG_START_A] =\n                    game.dialogPending[DIALOG_START_B] =\n                    game.dialogPending[DIALOG_HINT_1] =\n                    game.dialogPending[DIALOG_HINT_2] =\n                    game.dialogPending[DIALOG_HINT_3] = true;\n                }\n            }\n        }\n\n        defaultMovement(velocityAdj) {\n            if (Input.pointer) {\n                this.facing = vectorBetween(this.pos, uv2xy(Input.pointer));\n                this.facingAngle = vector2angle(this.facing) - R6;\n            }\n                    let v = {\n                            x:\n                                Input.direction.x *\n                                Input.direction.m *\n                                this.baseSpeed *\n                                velocityAdj,\n                            y:\n                                Input.direction.y *\n                                Input.direction.m *\n                                this.baseSpeed *\n                                velocityAdj\n                         };\n\n                        this.vel.x = (this.vel.x + v.x) / 2;\n                        this.vel.y = (this.vel.y + v.y) / 2;\n\n        }\n\n        fire() {\n            Audio.play(Audio.shotgun);\n\n            this.state = ATTACK;\n            this.frames = 10;\n            this.shellsLeft--;\n\n            let pos = {\n                x: this.pos.x + this.facing.x * 8 - this.facing.y * 3,\n                y: this.pos.y + this.facing.y * 8 + this.facing.x * 3\n            };\n\n            game.entities.push(new ShotgunBlast(pos, this.facingAngle));\n\n            // player knockback\n            this.vel = vector2point({ ...normalizeVector(this.facing), m: -1 });\n        }\n\n        reload(forced) {\n            this.forcedReload = forced;\n            this.state = RELOAD;\n            this.frames = 20;\n            this.shellsLeft = 0;\n            game.entities.push(new ReloadAnimation(this.frames));\n        }\n\n        draw() {\n            if (this.state === DEAD || this.state === SPAWN) return;\n\n            let sprite = Sprite.player[0],\n                blast,\n                headbob = (game.frame / 30 | 0) % 2;\n\n            if (this.state === ATTACK && this.frames >= 2) {\n                sprite = Sprite.player[1];\n                blast = Sprite.shotgun_blast[6 - this.frames];\n            }\n\n            //Sprite.drawViewportSprite(sprite, this.pos, this.facingAngle + R90);\n\n            let hf = this.state === RELOAD && !this.forcedReload ? 15 : 0;\n            for (let i = Math.min(hf, history.length); i >= 0; i--) {\n                let { u, v } = Sprite.viewportSprite2uv(\n                    sprite,\n                    this.history[i]\n                );\n\n                Viewport.ctx.save();\n                Viewport.ctx.globalAlpha = i === 0 ? 1 : 0.5;\n                Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);\n                Viewport.ctx.rotate(this.facingAngle + R90);\n\n                Viewport.ctx.drawImage(\n                    sprite.img,\n                    -sprite.anchor.x,\n                    -sprite.anchor.y\n                );\n                Viewport.ctx.drawImage(\n                    Sprite.player[2].img,\n                    -sprite.anchor.x,\n                    -sprite.anchor.y + headbob\n                );\n                if (blast) {\n                    Viewport.ctx.drawImage(\n                        blast.img,\n                        3 - blast.anchor.x,\n                        -20 - blast.anchor.y\n                    );\n                }\n                Viewport.ctx.restore();\n            }\n        }\n\n        releasePages() {\n            let number = Math.min(this.pages, 7);\n            let amount = this.pages / number | 0;\n            let remainder = this.pages - amount * number;\n\n            for (let i = 0; i < number; i++) {\n                game.entities.push(new Page(this.pos, amount + remainder));\n                remainder = 0;\n            }\n            this.pages = 0;\n        }\n    }\n\n    /**\n     * Monster\n     */\n    class Stabguts {\n        constructor(pos) {\n            this.pos = { ...pos };\n            this.hp = 200;\n            this.damage = [];\n            this.vel = { x: 0, y: 0 };\n            this.facing = { x: 0, y: -1, m: 0 };\n            this.radius = 8;\n            this.mass = 0.5;\n            this.lastAttack = 0;\n            this.state = CHASE;\n            this.enemy = true;\n            game.dialogPending[DIALOG_HINT_E1] = true;\n        }\n\n        think() {\n            let diff = this.facing = vectorBetween(this.pos, game.player.pos);\n            this.facingAngle = vector2angle(this.facing);\n            if (this.state === CHASE) {\n                if (diff.m < 38 && Math.random() < 0.05 && game.frame > this.lastAttack + 60) {\n                    this.state = RELOAD;\n                    this.frames = 24;\n                }\n                diff.m = clamp(diff.m, 0, 0.75);\n                this.vel = {\n                    x: (this.vel.x + diff.x * diff.m) / 2,\n                    y: (this.vel.y + diff.y * diff.m) / 2\n                };\n            } else if (this.state === RELOAD) {\n                if (this.frames-- === 0) {\n                    this.state = ATTACK;\n                    this.frames = 12;\n                }\n                this.vel = { x: 0, y: 0 };\n            } else if (this.state === ATTACK) {\n                if (this.frames-- === 0) {\n                    this.state = CHASE;\n                    this.lastAttack = game.frame;\n                }\n                if (this.frames === 1 && diff.m < 23) {\n                    game.player.damage.push({\n                        amount: 12,\n                        vector: diff,\n                        knockback: 5\n                    });\n                }\n                diff.m = clamp(diff.m, 0, 3);\n                this.vel = { x: diff.x * diff.m, y: diff.y * diff.m };\n            } else if (this.state === DEAD) {\n                this.cull = true;\n                Gore.kill(this);\n                game.entities.push(new Page(this.pos, 1));\n                game.entities.push(new Page(this.pos, 2));\n            }\n        }\n\n        draw() {\n            let sprite = Sprite.stabguts[((game.frame / 12) | 0) % 2];\n            this.state === RELOAD && (sprite = Sprite.stabguts[2]);\n            this.state === ATTACK && (sprite = Sprite.stabguts[3]);\n            Sprite.drawViewportSprite(\n                sprite,\n                this.pos,\n                this.facingAngle + R90\n            );\n        }\n    }\n\n    /**\n     * Monster\n     */\n    class Spindoctor {\n        constructor(pos) {\n            this.pos = { ...pos };\n            this.hp = 100;\n            this.damage = [];\n            this.radius = 3;\n            this.mass = 1;\n            this.bounce = true;\n            this.enemy = true;\n            game.dialogPending[DIALOG_HINT_E2] = true;\n\n            // Kick off at random angles, but, it looks weird to have straight horizontal\n            // or vertical angles - so avoid anything within +- 20 degrees of a straight angle.\n            let angle = Math.random() * R360;\n            if (angle % R90 < R20) angle += R20;\n            if (angle % R90 > R70) angle -= R20;\n            this.facing = angle2vector(angle);\n            this.vel = this.facing;\n            this.state = CHASE;\n        }\n\n        think() {\n            if (this.state === CHASE) {\n                let v = normalizeVector(this.vel);\n                v.m = (v.m + 2.5) / 2;\n                this.vel = vector2point(v);\n\n                let dist = vectorBetween(this.pos, game.player.pos);\n                if (dist.m <= this.radius + game.player.radius) {\n                    game.player.damage.push({\n                        amount: 5,\n                        vector: dist,\n                        knockback: 3\n                    });\n                }\n            } else if (this.state === DEAD) {\n                this.cull = true;\n                Gore.kill(this);\n                game.entities.push(new Page(this.pos, 1));\n                game.entities.push(new Page(this.pos, 2));\n            }\n        }\n\n        draw() {\n            Sprite.drawViewportSprite(Sprite.spindoctor[0], this.pos, game.frame / 5);\n            Sprite.drawViewportSprite(Sprite.spindoctor[1], this.pos);\n        }\n    }\n\n    const SpawnPatterns = [\n        [ // 50\n            [Stabguts,  1,1,1,1,1]\n        ],\n        [ // 55\n            [Spindoctor,1,1,1,1,1]\n        ],\n        [ // 60\n            [Stabguts,  5, , , ,1,1,1],\n            [Spindoctor, , , , ,3, ,3]\n        ],\n        [ // 65\n            [Stabguts,   ,1, ,1, ,1, ],\n            [Spindoctor,2, ,2, ,2, ,3]\n        ],\n        [ // 70\n            [Stabguts, 20, , , , , , , ],\n            [Spindoctor, , , , ,1,1,1,1]\n        ],\n        [ // 75\n            [Stabguts,   , , , , , ,6, ],\n            [Spindoctor,3, ,3, ,3, , ,3]\n        ]\n    ];\n\n    /**\n     * Brawl\n     */\n    const Brawl = {\n        perform() {\n            if (game.brawl) {\n                let livingEnemies = game.brawl.enemies.filter(enemy => !enemy.cull).length;\n\n                if (game.brawl.plan.length === 0) {\n                    if (livingEnemies === 0) {\n                        game.roomsCleared[game.brawl.room.roomNumber] = true;\n                        game.brawl = false;\n                    }\n                } else {\n                    let plan = game.brawl.plan[0];\n                    if (game.frame >= game.brawl.start + plan[1]) {\n                        if (Brawl.spawn(plan)) {\n                            game.brawl.plan.shift();\n                        }\n                    } else if (livingEnemies === 0) {\n                        // If nothing is alive, hasten the next enemy\n                        plan[1] -= 6;\n                    }\n\n                }\n            } else {\n                let qr = xy2qr(game.player.pos);\n                let room = game.maze.rooms[game.maze.maze[qr.r][qr.q]];\n                if (\n                    room &&\n                    room.roomNumber >= 5 &&\n                    !game.roomsCleared[room.roomNumber] &&\n                    !game.victory &&\n                    qr.q > room.q &&\n                    qr.r > room.r &&\n                    qr.q < room.q + room.w - 1 &&\n                    qr.r < room.r + room.h - 1\n                ) {\n                    game.screenshakes.push(new ScreenShake(20, 20, 20));\n                    game.brawl = {\n                        room,\n                        enemies: [],\n                        start: game.frame,\n                        plan: Brawl.expandPattern(SpawnPatterns[room.pattern])\n                    };\n                    Audio.play(Audio.alarm);\n                }\n            }\n        },\n\n        expandPattern(pattern) {\n            let plan = [];\n            for (let entry of pattern) {\n                let enemy = entry[0];\n                for (let i = 1; i < entry.length; i++) {\n                    for (let c = 0; c < entry[i] || 0; c++) {\n                        plan.push([enemy, (i - 1) * 30 + c * 10]);\n                    }\n                }\n            }\n            plan.sort((a, b) => a[1] - b[1]);\n            return plan;\n        },\n\n        spawn(plan) {\n            let pos = {\n                x: (Math.random() * (game.brawl.room.w * 32 - 32) | 0) + game.brawl.room.q * 32 + 16,\n                y: (Math.random() * (game.brawl.room.h * 32 - 32) | 0) + game.brawl.room.r * 32 + 16\n            };\n\n            let v = vectorBetween(game.player.pos, pos);\n            if (v.m > 48) {\n                let enemy = new plan[0](pos);\n                game.entities.push(enemy);\n                game.brawl.enemies.push(enemy);\n                game.entities.push(new SpawnAnimation(pos));\n                return enemy;\n            }\n        }\n    };\n\n    /**\n     * Movement\n     */\n    const Movement = {\n        perform(entities) {\n            // Movement only applies to active entities with positions and velocities\n            let movers = entities.filter(\n                entity => entity.pos && entity.vel && !entity.cull\n            );\n\n            // Very basic \"rounds\" of collision resolution, since we have no real physics.\n            // (As usual, \"detecting\" a collision is not the hard part... we need to resolve\n            // them too!)\n            for (let rounds = 0; rounds < 5; rounds++) {\n                // Each pair of entities only needs to interact once.\n                for (let i = 0; i < movers.length - 1; i++) {\n                    for (let j = i + 1; j < movers.length; j++) {\n                        Movement.clipVelocityEntityVsEntity(movers[i], movers[j]);\n                    }\n                }\n\n                for (let entity of movers) {\n                    Movement.clipVelocityAgainstWalls(entity);\n                }\n            }\n\n            // Now we perform all movement, even if it's not going to be perfect.\n            for (let entity of movers) {\n                entity.pos.x += entity.vel.x;\n                entity.pos.y += entity.vel.y;\n            }\n        },\n\n        clipVelocityEntityVsEntity(entity, other) {\n            if (entity.noClipEntity || other.noClipEntity) return;\n\n            let hit = intersectCircleCircle(\n                entity.pos,\n                entity.radius,\n                entity.vel,\n                other.pos,\n                other.radius,\n                other.vel\n            );\n            if (hit) {\n                if (entity.bounce && other.bounce) {\n                    entity.vel.x = -hit.nx * hit.m;\n                    entity.vel.y = -hit.ny * hit.m;\n                    other.vel.x = hit.nx * hit.m;\n                    other.vel.y = hit.ny * hit.m;\n                } else {\n                    // Not a bug: we \"add\" the mass of the opposing entity to our own velocity when deciding who\n                    // is at fault for the collision. Entity velocities adjust in relation to their fault level.\n                    let entityM = normalizeVector(entity.vel).m + other.mass,\n                        otherM = normalizeVector(other.vel).m + entity.mass,\n                        entityI = entity.bounce ? 0.1 : 1,\n                        otherI = other.bounce ? 0.1 : 1;\n                    entity.vel.x -=\n                        (hit.nx * hit.m * entityI * entityM) / (entityM + otherM);\n                    entity.vel.y -=\n                        (hit.ny * hit.m * entityI * entityM) / (entityM + otherM);\n                    other.vel.x +=\n                        (hit.nx * hit.m * otherI * otherM) / (entityM + otherM);\n                    other.vel.y +=\n                        (hit.ny * hit.m * otherI * otherM) / (entityM + otherM);\n                }\n            }\n        },\n\n        clipVelocityAgainstWalls(entity) {\n            if (entity.noClipWall) return;\n\n            for (let tile of tilesHitByCircle(\n                entity.pos,\n                entity.vel,\n                entity.radius\n            )) {\n                if (!tileIsPassable(tile.q, tile.r)) {\n                    let bounds = [\n                        qr2xy(tile),\n                        qr2xy({ q: tile.q + 1, r: tile.r + 1 })\n                    ];\n                    let hit = intersectCircleRectangle(\n                        entity.pos,\n                        {\n                            x: entity.pos.x + entity.vel.x,\n                            y: entity.pos.y + entity.vel.y\n                        },\n                        entity.radius,\n                        bounds\n                    );\n\n                    // The \"math\" part of detecting collision with walls is buried in the geometry functions\n                    // above, but it's not the whole story -- if we do detect a collision, we still need to\n                    // decide what to do about it.\n                    //\n                    // If the normal vector is horizontal or vertical, we zero out the portion of the vector\n                    // moving into the wall, allowing frictionless sliding (if we wanted to perform friction,\n                    // we could also reduce the other axis slightly).\n                    //\n                    // If the normal vector is not 90*, we \"back up\" off the wall by exactly the normal vector.\n                    // If the player runs into a corner at EXACTLY a 45 degree angle, they will simply \"stick\"\n                    // on it -- but one degree left or right and they'll slide around the corner onto the wall,\n                    // which is the desired result.\n                    if (hit) {\n                        if (entity.bounce) {\n                            if (hit.nx === 0) {\n                                entity.vel.y = -entity.vel.y;\n                            } else if (hit.ny === 0) {\n                                entity.vel.x = -entity.vel.x;\n                            } else {\n                                entity.vel.x += hit.nx;\n                                entity.vel.y += hit.ny;\n                            }\n                        } else {\n                            if (hit.nx === 0) {\n                                entity.vel.y = hit.y - entity.pos.y;\n                            } else if (hit.ny === 0) {\n                                entity.vel.x = hit.x - entity.pos.x;\n                            } else {\n                                entity.vel.x += hit.nx;\n                                entity.vel.y += hit.ny;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    class HealthChunkAnimation {\n        constructor(start, amount) {\n            this.start = start;\n            this.amount = amount;\n            this.t = -1;\n            this.d = 20;\n            this.z = 101;\n            this.y = 5;\n            this.vel = -0.7;\n            this.gravity = 0.09;\n        }\n\n        think() {\n            if (++this.t === this.d) this.cull = true;\n            this.y += this.vel;\n            this.vel += this.gravity;\n        }\n\n        draw() {\n            let x = this.start - this.amount + 8;\n\n            if (this.t > 15) Viewport.ctx.globalAlpha = 1 - this.t * 0.1;\n            Viewport.ctx.drawImage(\n                Sprite.hud_healthbar[2].img,\n                x,\n                3,\n                this.amount,\n                3,\n                x + 2,\n                this.y,\n                this.amount,\n                3\n            );\n            Viewport.ctx.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * Damage\n     */\n    const Damage = {\n        perform(entities) {\n            let hit = false;\n            for (let entity of entities) {\n                if (entity.hp) {\n                    if (entity.damage.length > 0) {\n                        if (entity.state !== DEAD && entity.state !== SPAWN) {\n                            for (let damage of entity.damage) {\n                                if (entity === game.player) {\n                                    game.entities.push(\n                                        new HealthChunkAnimation(\n                                            entity.hp,\n                                            damage.amount\n                                        )\n                                    );\n                                }\n                                entity.hp -= damage.amount;\n                                damage.vector.m = damage.knockback;\n                                entity.vel = vectorAdd(entity.vel, damage.vector);\n                                entity.lastDamage = damage;\n                                Gore.damage(entity);\n                                hit = true;\n                            }\n                        }\n                        entity.damage = [];\n                    }\n                    if (entity.hp <= 0 && entity.state !== DEAD) {\n                        entity.state = DEAD;\n                    }\n                }\n            }\n\n            if (hit) Audio.play(Audio.damage);\n        }\n    };\n\n    class Dialog {\n        constructor(key) {\n            let dialog = Dialog.details[key];\n            this.flag = key;\n            this.text = dialog.text;\n            this.speech = dialog.speech;\n            this.blockReload = dialog.blockReload;\n            this.blockFire = dialog.blockFire;\n            if (this.speech) {\n                this.blockMove = this.blockFire = this.blockReload = true;\n            }\n            this.t = 0;\n            this.d = this.speech ? 100 : 40;\n            this.z = 102;\n            game.dialog = this;\n        }\n\n        think() {\n            if (this.t < this.d) this.t++;\n            game.dialogSeen[this.flag] = true;\n\n            if (this.flag === DIALOG_HINT_1) {\n                if (Input.direction.m > 0) {\n                    this.cull = true;\n                    game.dialog = false;\n                }\n            } else if (this.flag === DIALOG_HINT_3) {\n                if (Input.pressed[Input.Action.RELOAD]) {\n                    this.cull = true;\n                    game.dialog = false;\n                }\n            } else {\n                if (Input.pressed[Input.Action.ATTACK]) {\n                    if (this.t < this.d) {\n                        this.t = this.d;\n                    } else {\n                        this.cull = true;\n                        game.dialog = false;\n                    }\n                }\n            }\n        }\n\n        draw() {\n            let sprite = Sprite.dialog_speech,\n                spriteu = Viewport.center.u + 5,\n                spritev = Viewport.center.v + 8,\n                textu = spriteu + 8,\n                textv = spritev + 12;\n\n            if (!this.speech) {\n                sprite = Sprite.dialog_hint;\n                spriteu = Viewport.center.u - Sprite.dialog_hint.img.width / 2;\n                spritev = Viewport.height - Sprite.dialog_hint.img.height - 8;\n                textu = spriteu + 5;\n                textv = spritev + 5;\n            }\n\n            Viewport.ctx.drawImage(sprite.img, spriteu, spritev);\n            Text.drawParagraph(\n                Viewport.ctx,\n                partialText(this.text, this.t, this.d),\n                textu, textv,\n                115, 50,\n                1,\n                Text.black,\n                Text.black_shadow\n            );\n        }\n    }\n\n    Dialog.details = [\n        {\n            text: 'SHOGGOTH\\'S ARMPIT! THE SHOTGUN ARCANA IS SCATTERED ALL OVER THIS DUNGEON!',\n            speech: true\n        },\n        {\n            text: 'HELP ME FIND ALL 404 MISSING PAGES AND GET ME OUT OF HERE!',\n            speech: true\n        },\n        {\n            text: 'USE WASD OR mnop TO MOVE',\n            blockFire: true,\n            blockReload: true\n        },\n        {\n            text: 'USE l TO FIRE YOUR SHOTGUN',\n            blockReload: true\n        },\n        {\n            text: 'USE r TO RELOAD',\n            blockFire: true\n        },\n        {\n            text: 'BE CAREFUL OUT THERE, WE NEED THOSE PAGES BACK!',\n            speech: true\n        },\n        {\n            text: 'STABGUTS! LOOK OUT FOR THE POINTY END.',\n            speech: true\n        },\n        {\n            text: 'SPINDOCTORS! YOU\\'LL GET MORE THAN A HAIRCUT FROM THOSE THINGS.',\n            speech: true\n        },\n        {\n            text: 'DON\\'T FORGET, PICK UP LOST PAGES TO RECOVER SOME HEALTH!',\n            speech: true\n        }\n    ];\n\n    /**\n     * DialogScheduling\n     */\n    const DialogScheduling = {\n        perform() {\n            if (!game.dialog && !game.brawl && !game.victory) {\n                for (let idx = 0; idx < Dialog.details.length; idx++) {\n                    if (game.dialogPending[idx] && !game.dialogSeen[idx]) {\n                        game.entities.push(new Dialog(idx));\n                        return;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Victory\n     */\n    const Victory = {\n        perform() {\n            if (game.player.pages >= 404 && !game.victory) {\n                Victory.frame = 0;\n                game.victory = true;\n                game.player.pos = roomCenter(game.maze.rooms[ROOM_ENDING]);\n                game.brawl = false;\n                for (let entity of game.entities) {\n                    if (entity.enemy) entity.state = DEAD;\n                }\n            } else if (game.victory) {\n                Victory.frame++;\n\n                if (Victory.frame === 10) {\n                    game.entities.push(new SpawnAnimation(game.player.pos));\n                    game.screenshakes.push(new ScreenShake(20, 20, 90));\n                }\n\n                let enemyCount = game.entities.filter(entity => entity.enemy).length;\n                if (Victory.frame % 30 === 0 && enemyCount < 25) {\n                    let pos = vectorAdd(game.player.pos, angle2vector(Math.random() * R360, 48));\n                    let enemyType = [Stabguts, Stabguts, Spindoctor][Math.random() * 3 | 0];\n                    let enemy = new enemyType(pos);\n                    game.entities.push(enemy);\n                    game.entities.push(new SpawnAnimation(pos));\n                }\n            }\n        }\n    };\n\n    /**\n     * Viewport\n     *\n     * Represents the game display (for us, a canvas).\n     */\n    const Maze = {\n        draw() {\n            let ctx = Viewport.ctx, maze = game.maze;\n\n            let offset = {\n                x: Viewport.center.u - game.camera.pos.x,\n                y: Viewport.center.v - game.camera.pos.y\n            };\n\n            let r1 = 0,\n                r2 = maze.h,\n                q1 = 0,\n                q2 = maze.w;\n\n            if (game.brawl) {\n                r1 = game.brawl.room.r;\n                r2 = r1 + game.brawl.room.h;\n                q1 = game.brawl.room.q;\n                q2 = q1 + game.brawl.room.w;\n\n                // During brawl, everything outside the room is hidden\n                Viewport.ctx.fillStyle = rgba(10, 10, 10, 1);\n                Viewport.fillViewportRect();\n            } else {\n                // Render wall tiles across the entire background\n                Viewport.ctx.drawImage(Sprite.tilebg.img, -16 - game.camera.pos.x % 32, -8 - game.camera.pos.y % 32);\n            }\n\n            for (let r = r1; r < r2; r++) {\n                for (let q = q1; q < q2; q++) {\n                    let x = q * 32 + offset.x,\n                        y = r * 32 + offset.y;\n                    if (x < -50 || y < -50 || x > 500 || y > 500) continue;\n\n                    let sprite = Sprite.tiles[maze.maze[r][q] ? 1 : 0];\n                    ctx.drawImage(sprite.img, x, y);\n                }\n            }\n\n            for (let r = r1; r < r2; r++) {\n                for (let q = q1; q < q2; q++) {\n                    let x = q * 32 + offset.x,\n                        y = r * 32 + offset.y;\n                    if (x < -50 || y < -50 || x > 500 || y > 500) continue;\n\n                    let coords = [\n                        [0, 0, 36, 4, x - 2, y - 2, 36, 4],\n                        [32, 0, 4, 36, x + 30, y - 2, 4, 36],\n                        [0, 32, 36, 4, x - 2, y + 30, 36, 4],\n                        [0, 0, 4, 36, x - 2, y - 2, 4, 36]\n                    ];\n\n                    for (let i = 0; i < 4; i++) {\n                        if (maze.walls[r][q] & (WALL_TOP << i)) {\n                            ctx.drawImage(Sprite.walls.img, ...coords[i]);\n                        }\n                    }\n\n                    if (game.brawl) {\n                        for (let i = 0; i < 4; i++) {\n                            if (maze.walls[r][q] & (OPEN_TOP << i)) {\n                                ctx.drawImage(Sprite.gates.img, ...coords[i]);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!game.brawl) {\n                for (let room of Object.values(maze.rooms)) {\n                    if (room.roomNumber >= 3 && !game.roomsCleared[room.roomNumber]) {\n                        let uv = xy2uv({\n                            x: (room.q + room.w / 2) * TILE_SIZE,\n                            y: (room.r + room.h / 2) * TILE_SIZE\n                        });\n                        Viewport.ctx.globalAlpha = 1 - (game.frame % 30) / 30;\n                        Text.drawText(Viewport.ctx, '!', uv.u - 4, uv.v - 10, 4, Text.red, Text.blue_shadow);\n                        Viewport.ctx.globalAlpha = 1;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Game state.\n     */\n    class Game {\n        init() {\n            Sprite.loadSpritesheet(() => {\n                Viewport.init();\n                Sprite.init();\n                Text.init();\n                Input.init();\n                Audio.init();\n\n                this.maze = MapLoader.loadMap();\n                this.entities = [];\n                this.dialogPending = {};\n                this.dialogSeen = {};\n                this.roomsCleared = {};\n                this.shadowCanvas = createCanvas(500, 500);\n                this.shadowOffset = 0;\n                this.screenshakes = [];\n                this.player = new Player();\n                this.entities.push(this.player);\n                this.camera = { pos: { ...this.player.pos } };\n\n                window.addEventListener('blur', () => this.pause());\n                window.addEventListener('focus', () => this.unpause());\n\n                this.start();\n            });\n        }\n\n        start() {\n            this.frame = 0;\n            this.update();\n            window.requestAnimationFrame(() => this.onFrame(1));\n        }\n\n        onFrame(currentms) {\n            this.frame++;\n            Viewport.resize();\n            this.update();\n            this.draw(Viewport.ctx);\n            window.requestAnimationFrame(() => this.onFrame(currentms));\n        }\n\n        update() {\n            // Pull in frame by frame button pushes / keypresses / mouse clicks\n            Input.update();\n\n            //if (Input.pressed[Input.Action.MENU]) {\n            //    this.paused ? this.unpause() : this.pause();\n            //}\n\n            if (this.paused) return;\n\n            // perform any per-frame audio updates\n            Audio.update();\n\n            // Behavior (AI, player input, etc.)\n            //perform(this.entities); <-- cut to save space\n            for (let entity of game.entities) {\n                if (entity.think) entity.think();\n            }\n\n            // perform any queued damage\n            Damage.perform(this.entities);\n\n            // Movement (perform entity velocities to position)\n            Movement.perform(this.entities);\n\n            // Dialog scheduling\n            DialogScheduling.perform();\n\n            // Brawl system (aka \"room battles\")\n            Brawl.perform();\n\n            // Victory condtions\n            Victory.perform();\n\n            // Culling (typically when an entity dies)\n            this.entities = this.entities.filter(entity => !entity.cull);\n\n            // Camera logic\n            let diff = {\n                x: this.player.pos.x - this.camera.pos.x,\n                y: this.player.pos.y - this.camera.pos.y\n            };\n            this.camera.pos.x += diff.x * 0.2;\n            this.camera.pos.y += diff.y * 0.2;\n\n            // Tick screenshakes and cull finished screenshakes\n            this.screenshakes = this.screenshakes.filter(screenshake =>\n                screenshake.update()\n            );\n\n            // Flickering shadows\n            if (game.frame % 6 === 0) this.shadowOffset = (Math.random() * 10) | 0;\n\n            // Intro screenshake\n            if (game.frame === 30) game.screenshakes.push(new ScreenShake(20, 20, 20));\n\n            // Initial \"click\" to get game started\n            if (Input.pressed[Input.Action.ATTACK] && !game.started) game.started = true;\n\n            // Web Monetization!\n            if (document.monetization) {\n                game.powerup = true;\n                game.player.shellsMax = 5;\n                game.player.baseSpeed = 1.9;\n            }\n        }\n\n        draw() {\n            // Reset canvas transform and scale\n            Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            Viewport.ctx.scale(Viewport.scale, Viewport.scale);\n\n            // Render screenshakes (canvas translation)\n            let shakeX = 0, shakeY = 0;\n            this.screenshakes.forEach(shake => {\n                shakeX += shake.x;\n                shakeY += shake.y;\n            });\n            Viewport.ctx.translate(shakeX, shakeY);\n\n            Maze.draw();\n\n            for (let entity of this.entities) {\n                if (!entity.z || entity.z < 100) entity.draw();\n            }\n\n            Viewport.ctx.drawImage(\n                Sprite.shadow.img,\n                0,\n                0,\n                500,\n                500,\n                -this.shadowOffset,\n                -this.shadowOffset,\n                Viewport.width + this.shadowOffset * 2,\n                Viewport.height + this.shadowOffset * 2\n            );\n\n            Hud.draw();\n\n            for (let entity of this.entities) {\n                if (entity.z && entity.z > 100) entity.draw();\n            }\n\n            if (game.frame < 120) {\n                Viewport.ctx.fillStyle = rgba(0, 0, 0, 1 - game.frame / 120);\n                Viewport.fillViewportRect();\n            }\n\n            if (game.frame >= 30 && !game.started) {\n                let title = 'WIZARD WITH A SHOTGUN';\n                let width = Text.measureWidth(title, 3);\n                Text.drawText(\n                    Viewport.ctx, title, (Viewport.width - width) / 2, Viewport.height / 2, 3,\n                    Text.white,\n                    Text.red\n                );\n            }\n\n            if (game.victory) {\n                Viewport.ctx.fillStyle = rgba(240, 0, 0, clamp(Victory.frame / 1800, 0, 0.7));\n                Viewport.fillViewportRect();\n\n                let text = 'WAIT! THE PORTAL HOME... \\n \\nIT STINKS LIKE ROTTEN MEAT, BUT IT LOOKS LIKE YOU ARE STUCK IN THE DUNGEONS.';\n                Text.drawParagraph(\n                    Viewport.ctx,\n                    partialText(text, Victory.frame, 600),\n                    40, 40,\n                    Viewport.width - 80,\n                    Viewport.ctx.height - 80,\n                    2,\n                    Text.white,\n                    Text.red\n                );\n            }\n        }\n\n        pause() {\n            if (this.paused) return;\n            this.paused = true;\n            Audio.pause();\n        }\n\n        unpause() {\n            if (!this.paused) return;\n            this.paused = false;\n            Audio.unpause();\n        }\n    }\n\n    const game = new Game();\n\n    /**\n     * Create and launch game.\n     */\n    game.init();\n\n}());\n"]}